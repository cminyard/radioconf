#!/usr/bin/env python3
#
#    radio_edit - Edit radio clone files
#    Copyright (C) 2009  Corey Minyard
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor,
#      Boston, MA  02110-1301  USA

import sys
import traceback
import tkinter.tix
import tkinter.dialog
import os
import locale

radiodir = "@YCONF@"

decimal_digits = "0123456789"

class ParseException(Exception):
    def __init__(self, filename, lineno, err):
        self.filename = filename
        self.lineno = lineno.get()
        self.err = err
        pass

    def __str__(self):
        return self.filename + "(" + str(self.lineno) + "): " + self.err

    pass

class DataException(Exception):
    def __init__(self, err):
        self.err = err
        pass

    def __str__(self):
        return self.err

    pass

class LineNum:
    def __init__(self):
        self.val = 0
        return

    def get(self):
        return self.val

    def inc(self):
        self.val += 1
        return
    pass

###############################################################################
#
# Radio information parsing and storage.
#
###############################################################################
class RadioInfo:
    def __init__(self, name):
        self.name = name;
        self.headercmp = []
        return

    pass

radios = []

def find_radio(data):
    for r in radios:
        if (len(data) < len(r.headercmp)):
            continue
        found = True
        i = 0
        for b in r.headercmp:
            if (b != data[i]):
                found = False
                break
            i += 1
            pass
        if (found):
            return r.name
        pass
    return None

# Throws IOError and ParseException
def read_radios():
    filename = os.path.join(radiodir, "radios")
    f = open(filename, "r");
    try:
        lineno = LineNum()
        in_radio = False
        l = ""
        while True:
            l += f.readline()
            if (not l):
                break;
            lineno.inc()
            if l[len(l) - 1] == '\\':
               continue
            if l[0] == '#':
                l = ""
                continue
            v = l.split();
            l = ""
            if (not v):
                continue
            if (v[0] == "radio"):
                if (in_radio):
                    raise ParseException(filename, lineno,
                                         "Got radio start inside a radio")
                if (len(v) < 2):
                    raise ParseException(filename, lineno,
                                         "No radio specified")
                curr_radio = RadioInfo(v[1])
                in_radio = True
                continue
            if (v[0] == "endradio"):
                if (not in_radio):
                    raise ParseException(filename, lineno,
                                         "Got radio end outside a radio")
                if (len(curr_radio.headercmp) == 0):
                    raise ParseException(filename, lineno,
                                         "No headercmp for radio")
                radios.append(curr_radio)
                in_radio = False
                continue
            if (v[0] == "headercmp"):
                if (not in_radio):
                    raise ParseException(filename, lineno,
                                         "Got headercmp outside a radio")
                try:
                    i = 0
                    found = True
                    for ns in v[1:]:
                        n = int(ns, 16)
                        if (n > 255):
                            raise TypeError("Number too large")
                        curr_radio.headercmp.append(n)
                        i += 1
                        pass
                    pass
                except TypeError as e:
                    raise ParseException(filename, lineno,
                                         "invalid hexadecimal 8-bit number")
                except ValueError as e:
                    raise ParseException(filename, lineno,
                                         "invalid hexadecimal 8-bit number")
                pass
            pass
        pass
    except:
        exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
        f.close()
        raise exceptionType(exceptionValue).with_traceback(exceptionTraceback)
    return

###############################################################################
#
# Handling of repeater offsets
#
###############################################################################
def getHz(s, filename, lineno):
    v = 0
    numdec = 0
    postdec = 0
    units = None
    l = 0
    for c in s:
        if (c == '.'):
            if (numdec > 0):
                if (postdec != 3):
                    raise ParseException(filename, lineno,
                                         "Invalid number %s" % s)
                pass
            postdec = 0
            numdec += 1
            l += 1
            continue
        d = decimal_digits.find(c)
        if (d == -1):
            units = s[l:]
            break
        postdec += 1

        v *= 10
        v += d
        l += 1
        pass

    if (numdec > 0):
        if (postdec > 3):
            raise ParseException(filename, lineno,
                                 "Invalid number %s" % s)
        v *= (10 ** (3 - postdec)) # Extend n.n to n.nnn
        pass

    if (units):
        if (units == "MHz"):
            while (numdec < 2):
                v *= 1000
                numdec += 1
                pass
            pass
        elif (units == "kHz"):
            while (numdec < 1):
                v *= 1000
                numdec += 1
                pass
            pass
        elif (units == "Hz"):
            pass
        else:
            raise ParseException(filename, lineno,
                                 "Invalid units %s" % units)
        pass

    return v

def getCountry():
    l = locale.getdefaultlocale()
    if (not l):
        return None
    l = l[0].split("_")
    if len(l) < 2:
        return None
    return l[1]

class RepeaterOffsets:
    def __init__(self, country=None):
        self.offsets = []

        if (country is None):
            country = getCountry()
            if (not country):
                return
            pass

        filename = os.path.join(radiodir, country + ".rpt")
        try:
            fd = open(filename, "r")
        except IOError as e:
            print("Can't load repeater offsets: " + str(e))
            return

        try:
            lineno = LineNum()
            while True:
                l = fd.readline();
                if (not l):
                    break
                lineno.inc()
                if l[0] == '#':
                    continue
                v = l.split();
                if not v:
                    continue
                if len(v) != 4:
                    raise ParseException(filename, lineno,
                                         "Invalid number of elements on line")
                if v[2] != "+" and v[2] != "-":
                    raise ParseException(filename, lineno,
                                         "Invalid offset, must be + or -")

                self.offsets.append((getHz(v[0], filename, lineno),
                                     getHz(v[1], filename, lineno),
                                     v[2],
                                     getHz(v[3], filename, lineno)))
                pass
            pass
        except ParseException as e:
            print(e)
        return

    def calcOffset(self, freq):
        for e in self.offsets:
            if ((freq >= e[0]) and (freq <= e[1])):
                return (e[2], e[3])
            pass
        return ("smplx", 0)

    pass

###############################################################################
#
# Configuration information
#
###############################################################################
class GenConfig:
    def __init__(self):
        self.doRptOffsets = True
        self.rptoff = RepeaterOffsets()
        return
    pass

###############################################################################
#
# Raw file data handling
#
###############################################################################
class Address:
    """This holds an address in a radio file.  It is a set of
    locations (entries), each holding a 4-tuple: start byte, start bit,
    length (in bits), and a offset between succeeding entries."""
    def __init__(self, c, s, base=0):
        l = len(s)
        if (l == 0):
            raise ParseException(c.filename, c.lineno,
                                 "Empty location");
        if (s[0] != '('):
            raise ParseException(c.filename, c.lineno,
                                 "Address doesn't start with (");
        if (s[l-1] != ')'):
            raise ParseException(c.filename, c.lineno,
                                 "Address doesn't end with )");
        self.entries = []
        self.revbits = False # Bits are numbered from 0 by default
        i = 1
        l -= 1
        pos = 0
        start = i
        v = [0, 0, 0, 0]
        self.entries.append(v)
        while (i < l):
            if (s[i] == ','):
                v[pos] = self.parseNum(c, s[start:i], base)
                start = i + 1
                pos += 1
                if (pos > 3):
                    raise ParseException(c.filename, c.lineno,
                                         "Address has too many values"
                                         + " in a field");
                pass
            elif (s[i] == ':'):
                if (pos < 2 or pos > 3):
                    raise ParseException(c.filename, c.lineno,
                                         "Address has too few values"
                                         + " in a field");
                v[pos] = self.parseNum(c, s[start:i], base)
                start = i + 1
                pos = 0
                v = [0, 0, 0, 0]
                self.entries.append(v)
                pass
            i += 1
            pass
        if (pos < 2 or pos > 3):
            raise ParseException(c.filename, c.lineno,
                                 "Address has too few values"
                                 + " in a field");
        if ((pos == 3) and (s[start] == 'r')):
            # Number bits starting with the high order.
            start += 1
            self.revbits = True
            pass
        v[pos] = self.parseNum(c, s[start:i], base)
        return

    def parseNum(self, c, s, base):
        l = len(s)
        if (s[l-1] == '*'):
            v = c.toNum(s[0:l-1]) + base
        else:
            v = c.toNum(s[0:l])
            pass
        return v

    def numbits(self):
        numbits = 0
        for a in self.entries:
            numbits += a[2]
            pass
        return numbits

    pass

class RadioFileData:
    # Throws IOError
    def __init__(self, filename):
        self.filename = filename
        f = open(filename, "rb")
        strdata = f.read();
        f.close()
        self.data = []
        for c in strdata:
            self.data.append(c)
        self.changed = False
        pass

    def write(self, filename=None):
        if (filename == None):
            filename = self.filename
        else:
            self.filename = filename
            pass
        try:
            f = open(filename, "wb")
            f.write(bytes(self.data))
        finally:
            f.close()
            pass
        self.changed = False
        pass

    # The get and set routine throw IndexError if out of range.

    def get_bits(self, addr, num):
        v = 0
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off // 8
            bit_off %= 8
            numbits = a[2]
            v <<= numbits

            if (addr.revbits):
                # FIXME - This doesn't work for multi-byte revbits
                x = self.data[byte_off] >> (8 - numbits - bit_off)
            else:
                x = self.data[byte_off] >> bit_off
                pass
            bitsleft = numbits - (8 - bit_off)
            while (bitsleft >= 8):
                byte_off += 1
                x <<= 8
                x |= self.data[byte_off]
                bitsleft -= 8
                pass
            if (bitsleft > 0):
                byte_off += 1
                x <<= bitsleft
                if (addr.revbits):
                    x1 = self.data[byte_off] >> (8 - bitsleft)
                    x1 &= ~(0xffffffff << bitsleft)
                    x |= x1
                else:
                    x |= self.data[byte_off] & ~(0xffffffff << bitsleft)
                    pass
                pass
            v |= x & ~(0xffffffff << numbits)
            pass
        return v

    def set_bits(self, vt, addr, num):
        self.changed = True
        bitsleft = 0
        for a in addr.entries:
            bitsleft += a[2]
            pass
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off // 8
            bit_off %= 8
            numbits = a[2]
            bitsleft -= numbits

            v = vt >> bitsleft
            v = v & ~(0xffffffff << numbits)

            x = self.data[byte_off]
            if ((bit_off + numbits) <= 8):
                # Special case, all in one byte
                if (addr.revbits):
                    mask = (0xff >> (8 - numbits)) << (8 - numbits - bit_off)
                else:
                    mask = (0xff >> (8 - numbits)) << bit_off
                    pass
                x &= ~mask
                if (addr.revbits):
                    x |= (v << (8 - numbits - bit_off)) & mask
                else:
                    x |= (v << bit_off) & mask
                    pass
                self.data[byte_off] = x
                continue
            # FIXME - no support for the 'r' flag in the following.
            mask = 0xff << bit_off
            x &= ~mask
            self.data[byte_off] = x | ((v >> (numbits - (8 -bit_off))) & mask)
            self.data[byte_off] &= 0xff
            byte_off += 1
            numbits -= 8 - bit_off
            while (numbits >= 8):
                self.data[byte_off] = (v >> (numbits - 8)) & 0xff
                self.data[byte_off] &= 0xff
                byte_off += 1
                numbits -= 8
                pass
            if (numbits > 0):
                mask = 0xff << numbits
                x = self.data[byte_off]
                x &= mask
                x |= v & ~mask;
                self.data[byte_off] = x & 0xff
                pass
            pass
        pass

    def get_bytes(self, addr, num):
        byte_pos = addr.entries[0][0] + (addr.entries[0][3] * num // 8)
        numbytes = addr.entries[0][2] // 8
        return self.data[byte_pos:byte_pos+numbytes]

    def set_byte(self, v, addr, num, offset):
        byte_pos = addr.entries[0][0] + (addr.entries[0][3] * num // 8)
        self.changed = True
        self.data[byte_pos + offset] = v
        pass

    pass


###############################################################################
#
#
#
###############################################################################
class HandlerTie:
    def __init__(self, handler, tie):
        self.handler = handler
        self.tie = tie
        return
    pass

class Handler:
    """This is an internal type that eases handling events for a type.
    The type objects do not own the data about the particular object
    they are used to represent, since they are reused for many
    different objects.  Instead, when a widget is allocated to handle
    a particular type, one of these is allocated to hold that data and
    deliver it to the type object."""
    def __init__(self, handler, data, wtype):
        self.handler = handler
        self.data = data
        self.type = wtype
        self.widget = None # Will be filled in later by the type
        self.foreground = None # Filled in if needed

        # The set of widgets/handlers we are tied to.  When the widget
        # associated with this handler changes, we call everything in
        # the tie list.  This is a list of HandlerTie object.
        self.tielist = []

        # These are ties to me that change the way I behave.  We keep these
        # as lists becaue there may be more than one tie to me, and only
        # one of them is required to be valid, so we may have to scan them.
        self.offtie = []
        self.basefreqtie = []
        self.offfreqtie = []
        self.lastbfreq = None

        self.enabletie = None
        self.enableoffsettie = None
        pass

    def addTie(self, h, tie):
        self.tielist.append(HandlerTie(h, tie))

        # Inform the widget we are tied to them, in case they care
        h.newTie(self, tie)
        return

    def newTie(self, fromh, tie):
        self.type.newTie(self, fromh, tie)
        if (fromh.widget):
            fromh.modified(newtie=True)
        return

    def tieChanged(self, h, newtie):
        self.type.tieChanged(self, h, newtie)
        return

    # Called when the user modifies a value.  Not required for setSelect
    # because that does a full redisplay.  Causes any tied values to be
    # redisplayed.
    def modified(self, newtie=False):
        for ht in self.tielist:
            ht.tie.tieChanged(ht.handler, newtie)
            pass
        return

    def getValue(self, num):
        return self.type.getValue(self, num)

    def getSelect(self, num):
        return self.type.getSelect(self, num)

    def setSelect(self, v, num):
        return self.type.setSelect(v, self, num)

    def redisplay(self, h):
        self.type.redisplay(h)
        return

    def set(self):
        self.handler(self)
        pass

    def set_event(self, event):
        return self.handler(self, event)

    pass

###############################################################################
#
#
#
###############################################################################
def rewriteEntry(w, v):
    """Rewrite the value in an entry widget, setting the state to normal so
    it is writable, the setting the value, then setting the state back"""

    oldstate = w["state"]
    if (oldstate != "normal"):
        w["state"] = "normal"
        pass
    w.delete(0, 'end')
    w.insert(0, v)
    if (oldstate != "normal"):
        w["state"] = oldstate
        pass
    return

class YType:
    """This is the base class for all the different types that may be
    declared in a radio file."""
    def __init__(self, name):
        self.name = name
        self.displayheader = True
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        return None

    def getWidgetHandler(self, parent, t, num):
        h = Handler(None, None, self)
        h.num = num
        h.widget = None
        return h

    def renumWidget(self, h, num):
        if h.enabletie:
            v = int(h.enabletie.getValue(num))
            if v:
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "disabled"
                pass
            pass
        elif h.enableoffsettie:
            v = h.enableoffsettie.getValue(num)
            if (v == "+" or v == "-"):
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "disabled"
                pass
            pass
        pass

    def redisplay(self, h):
        self.renumWidget(h, h.num)
        return

    def tieChanged(self, h, newtie):
        self.redisplay(h)
        return

    def checkAddrOk(self, c, addr):
        return True

    def getSelect(self, h, num):
        return ""

    def getValue(self, h, num):
        # Most types are the same for select and value
        return self.getSelect(h, num)

    def setSelect(self, v, h, num, default=None):
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "enable"):
            myh.enabletie = fromh
        elif (tie.tietype == "enableoff"):
            myh.enableoffsettie = fromh
        elif (tie.tietype != "normal"):
            print(("Warning: Unknown type %s tie to %s"
                  % (tie.tietype, tie.value)))
            pass
        if (myh.widget):
            self.redisplay(myh)
            pass
        return

    pass

class BISpecial(YType):
    def __init__(self, name="Special"):
        YType.__init__(self, name)
        self.displayheader = False
        pass

    def getWidgetHandler(self, parent, t, num):
        h = Handler(None, t, self)
        # This is not actually displayed.
        h.widget = None
        h.num = num
        return h

    def getSelect(self, h, num):
        t = h.data
        return str(t.data.get_bits(t.addr, num))

    def getValue(self, h, num):
        t = h.data
        return str(t.data.get_bits(t.addr, num))

    def setSelect(self, v, h, num, default=None):
        t = h.data
        try:
            t.data.set_bits(int(v), t.addr, num)
        except Exception as e:
            if default is not None:
                try:
                    t.data.set_bits(int(default), t.addr, num)
                except:
                    pass
                pass
            pass
        return

    pass

class BISpecial857A(BISpecial):
    def __init__(self, name="Special857A"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "offset"):
            myh.offtie.append(fromh)
        elif (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        if (myh.widget):
            self.redisplay(myh)
            pass
        return

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        oldv = t.data.get_bits(t.addr, num)
        if (off and off != "split"):
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
            return

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (not bfreq):
            # bfreq should be coming later, don't get it now.
            return

        bfreq = int(bfreq)
        if (bfreq < 4000000):
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
                pass
        elif (bfreq < 8000000):
            if (oldv != 1):
                t.data.set_bits(1, t.addr, num)
                pass
        elif (bfreq < 11000000):
            if (oldv != 2):
                t.data.set_bits(2, t.addr, num)
                pass
        elif (bfreq < 14000000):
            if (oldv != 3):
                t.data.set_bits(3, t.addr, num)
                pass
        elif (bfreq < 40000000):
            if (oldv != 4):
                t.data.set_bits(4, t.addr, num)
                pass
        else:
            if (oldv != 5):
                t.data.set_bits(5, t.addr, num)
                pass
            pass
        pass

    pass

class BISpecial857B(BISpecial):
    def __init__(self, name="Special857B"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        return

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        oldv = t.data.get_bits(t.addr, num)
        bfreq = int(bfreq)
        if (not bfreq):
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
            return
        if (bfreq < 0x4000000):
            if (oldv != 1):
                t.data.set_bits(1, t.addr, num)
        else:
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
            pass
        pass

    pass

class BISpecialTMV71(BISpecial):
    """There is a location that is either VHF (0x05) or UHF (0x08) depending
       on the frequency set."""
    def __init__(self, name="SpecialTMV71"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        return

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        bfreq = int(bfreq)
        oldv = t.data.get_bits(t.addr, num)
        if (bfreq > 400000000):
            t.data.set_bits(0x05, t.addr, num)
        else:
            t.data.set_bits(0x08, t.addr, num)
            pass
        pass
    pass

class BISetToZero(BISpecial):
    def __init__(self, name="SetToZero"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "normal"):
            myh.offtie.append(fromh)
            pass
        return

    def renumWidget(self, h, num):
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if off is None:
            off = True
        else:
            off = int(off)
            pass

        if (off):
            t = h.data
            oldv = t.data.get_bits(t.addr, num)
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
                pass
            pass
        pass

    pass

class BIInt(YType):
    valid_digits = decimal_digits
    conv_val = 10

    def __init__(self, name="Int"):
        YType.__init__(self, name)
        return

    def setup(self, minval, maxval, offset, multi, units):
        self.minval = minval
        self.maxval = maxval
        self.unsigned = minval >= 0
        self.offset = offset
        self.multi = multi
        self.units = units
        self.unitslen = len(units)
        return

    def newInst(self, name):
        return BIInt(name=name)

    def matchName(self, c, string):
        if not string.startswith(self.name + "("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 self.name + " does not end with ')'")
        spec = string[4:len(string)-1].split(",")
        if (len(spec) != 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid %s specifier" % self.name)
        minval = c.toNum(spec[0])
        maxval = c.toNum(spec[1])
        if (minval >= maxval):
            raise ParseException(c.filename, c.lineno,
                                 "min must be < max value")
        offset = c.toNum(spec[2])
        multi = c.toNum(spec[3])
        if (multi <= 0):
            raise ParseException(c.filename, c.lineno,
                                 "Multiplier must be > 0")
        units = spec[4]
        b = self.newInst(name=string)
        b.setup(minval, maxval, offset, multi, units)
        return b

    def getWidgetHandler(self, parent, t, num):
        v = self.getInt(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        w = tkinter.tix.Entry(parent, readonlybackground="tan")
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, self.convFromNum(v)+self.units)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        rewriteEntry(h.widget, str(v)+self.units)
        pass

    def getInt(self, data, addr, num):
        v = data.get_bits(addr, num)
        if (not self.unsigned):
            n = addr.numbits()
            if ((1 << n) & v):
                # Negative value
                v |= (-1 << n) | v
                pass
            pass
        v += self.offset
        v *= self.multi
        return v

    def setInt(self, v, data, addr, num):
        v //= self.multi
        v -= self.offset
        if (v < 0):
            v &= (-1 << addr.numbits())
            pass
        data.set_bits(v, addr, num)
        return

    def getSelect(self, h, num):
        t = h.data
        return str(self.getInt(t.data, t.addr, num))

    def setSelect(self, v, h, num, default=None):
        t = h.data
        try:
            self.setInt(int(v), t.data, t.addr, num)
        except Exception as e:
            if default is not None:
                try:
                    self.setInt(int(default), t.data, t.addr, num)
                except:
                    pass
                pass
            pass
        pass

    def convFromNum(self, v):
        return str(v)

    def convToNum(self, s):
        try:
            i = int(s, self.conv_val)
            if ((i < self.minval) or (i > self.maxval)):
                return None
            pass
        except Exception as e:
            return None

        return i

    def set(self, h, event):
        c = event.keysym
        if ((c == "Left") or (c == "Right")
            or (c == "Up") or (c == "Down")):
            # Let these through
            return
        if (c == "minus"):
            c = '-'
        elif ((c == "BackSpace") or (c == "Delete")):
            pass
        elif (len(c) > 1):
            return "break" # Ignore other editing keys
        if (c == '-' and self.unsigned):
            return "break"

        w = h.widget
        cursor = w.index("insert")
        end = w.index("end")
        if (cursor > (end - self.unitslen)):
            # Don't mess with the units.
            return "break"

        s = w.get()

        if (c == "BackSpace"):
            if (cursor == 0):
                return "break"
            s = s[0:cursor - 1] + s[cursor:]
            cursor -= 2
        elif (c == "Delete"):
            if (cursor >= len(s)):
                return "break"
            s = s[0:cursor] + s[cursor + 1:]
            cursor -= 1
        elif (c not in self.valid_digits) and (c != '-'):
            return "break" # Ignore everything but numbers and '-'
        else:
            s = s[0:cursor] + c + s[cursor:]
            pass

        intstr = s[0:len(s)-self.unitslen]
        v = self.convToNum(intstr)
        if (v is not None):
            t = h.data
            self.setInt(v, t.data, t.addr, h.num)
            if (h.foreground):
                w['foreground'] = h.foreground
                h.foreground = None
                pass
            pass
        else:
            # Turn the value red if out of range.
            if (h.foreground is None):
                h.foreground = w['foreground']
                w['foreground'] = 'red'
                pass
            pass
        h.widget.delete(0, 'end')
        w.insert(0, s)
        w.icursor(cursor + 1)
        return "break"

    pass

class BIHex(BIInt):
    valid_digits = decimal_digits + "ABCDEFabcdef"
    conv_val = 16

    def __init__(self, name="Hex"):
        YType.__init__(self, name)
        return

    def newInst(self, name):
        return BIHex(name=name)

    def convFromNum(self, v):
        return "%x" % v

    pass

class BIString(YType):
    valid_chars = "0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,:;!\"#$%&'()*+-/=<>?@[]^_\\{|}`~"

    def __init__(self, name="String", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        elif string.startswith("String("):
            if not string.endswith(")"):
                raise ParseException(c.filename, c.lineno,
                                     "String does not end with ')'")
            spec = string[7:len(string)-1].split(",")
            if (len(spec) != 1):
                raise ParseException(c.filename, c.lineno,
                                     "Invalid String specifier")
            width = c.toNum(spec[0])
            return BIString(name=string, width=width)
        return None

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "String formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must be a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_string(self, data, addr, num):
        s = data.get_bytes(addr, num)
        for i in range(0, len(s)):
            if (chr(s[i]) not in self.valid_chars):
                s[i] = ' '
            else:
                s[i] = chr(s[i])
                pass
            pass
        s = "".join(s)
        return s

    def set_string(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] // 8
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                p = " "
            else:
                p = v[i].upper()
                pass
            data.set_byte(ord(p), addr, num, i)
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_string(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        h.v = v
        h.num = num
        w = tkinter.tix.Entry(parent, readonlybackground="tan")
        w["width"] = self.width
        h.widget = w
        w.bind("<KeyRelease>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        rewriteEntry(h.widget, self.get_string(t.data, t.addr, num));
        pass

    def getSelect(self, h, num):
        t = h.data
        return self.get_string(t.data, t.addr, num)

    def setSelect(self, v, h, num, default=None):
        t = h.data
        self.set_string(v, t.data, t.addr, num, None)
        pass

    def set(self, h, event):
        w = h.widget
        t = h.data
        v = w.get()
        if (v == h.v):
            return
        cursor = w.index("insert")
        self.set_string(v, t.data, t.addr, h.num, h)
        v = self.get_string(t.data, t.addr, h.num)
        w.delete(0, 'end')
        w.insert(0, v)
        w.icursor(cursor)
        h.v = v
        pass
    pass


class BIFixed(YType):
    def __init__(self, name="Fixed", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def setup(self, pre, suf, inc, units, snddec):
        # Number of digits to the left of the decimal
        self.pre = pre
        # Number of digits to the right of the decimal
        self.suf = suf
        # Each integer increment adds this much
        self.inc = inc
        # Units (like kHz, MHz, etc)
        self.units = units
        # Second decimal place location, -1 for none
        self.snddec = snddec

        self.numdec = 1

        # Total string length is prefix + suffix + the period
        self.len = pre + suf + 1
        if (self.snddec >= 0):
            self.snddec += 1 # Account for the first '.'
            self.len += 1
            self.numdec += 1
        pass

    def get_raw(self, t, num):
        return t.data.get_bits(t.addr, num)

    def set_raw(self, t, v, num):
        t.data.set_bits(v, t.addr, num)
        return

    def matchName(self, c, string):
        if not string.startswith("Fixed("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 "Fixed does not end with ')'")
        spec = string[6:len(string)-1].split(",")
        if (len(spec) < 4) or (len(spec) > 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid Fixed specifier")
        pre = c.toNum(spec[0])
        suf = c.toNum(spec[1])
        inc = c.toNum(spec[2])
        units = spec[3]
        snddec = -1
        width = self.width
        if (len(spec) >= 5):
            opts = spec[4].split(":")
            for opt in opts:
                o = opt.split("=", 1)
                if (o[0] == "w"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "w option requires value")
                    width = c.toNum(o[1])
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "Invalid Fixed option: " + o[0])
            pass
        b = BIFixed(name=string, width=width)
        b.setup(pre, suf, inc, units, snddec)
        return b

    def getWidgetHandler(self, parent, t, num):
        v = self.get_raw(t, num)
        h = Handler(self.set, t, self)
        w = tkinter.tix.Entry(parent, readonlybackground="tan")
        w["width"] = self.width
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, self.conv_to_str(v))
        return h

    def getBits(self, h, num):
        t = h.data
        return self.get_raw(t, num)

    def setBits(self, v, h, num):
        t = h.data
        self.set_raw(t, v, num)
        return

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        v = self.getBits(h, num)
        rewriteEntry(h.widget, self.conv_to_str(v))
        pass

    def getSelect(self, h, num):
        return self.conv_to_str(self.getBits(h, num))

    def getValue(self, h, num):
        t = h.data
        return str(self.get_raw(t, num))

    def setSelect(self, v, h, num, default=None):
        self.setBits(self.conv_from_str(v), h, num)
        pass

    def set(self, h, event):
        if ((event.keysym == "Left") or (event.keysym == "Right")
            or (event.keysym == "Tab") or (event.keysym == "ISO_Left_Tab")
            or (event.keysym == "Up") or (event.keysym == "Down")):
            # Let these through
            return
        if (len(event.keysym) > 1):
            return "break" # Ignore other editing keys

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= self.len):
            return "break" # Past the end of the entry
        if (cursor == self.pre) or (cursor == self.snddec):
            w.icursor(cursor + 1) # Skip over the '.'
            return "break"

        c = event.keysym
        if (c not in decimal_digits):
            return "break" # Ignore everything but numbers

        s = w.get()
        if (s[cursor] != c):
            s = s[0:cursor-1] + c + s[cursor:]
            w.delete(cursor)
            w.insert(cursor, c)
            v = self.conv_from_str(w.get())
            self.setBits(v, h, h.num)
            h.modified()
            s = self.conv_to_str(v)
            h.widget.delete(0, 'end')
            w.insert(0, s)
            pass
        if (cursor == self.pre - 1) or (cursor == self.snddec - 1):
            w.icursor(cursor + 2) # Skip over the '.'
        else:
            w.icursor(cursor + 1)
        return "break"

    def conv_from_str(self, s):
        v = 0
        l = 0
        decloc = -1
        postdec = 0
        units = None
        for c in s:
            if (c == '.'):
                if (decloc == -1):
                    decloc = l
                    pass
                continue
            d = decimal_digits.find(c)
            if (d == -1):
                # Must be in the units
                units = s[l:]
                if (decloc == -1):
                    decloc = l
                    pass
                break
            if (decloc != -1):
                postdec += 1
                pass
            v *= 10
            v += d
            l += 1
            pass
        if (decloc == -1):
            decloc = l
            pass
        if (units and units != self.units):
            # Need to do a units conversion.
            if (self.units == "MHz"):
                if (units == "kHz"):
                    decloc -= 3
                    postdec += 3
                elif (units == "Hz"):
                    decloc -= 6
                    postdec += 6
                    pass
                pass
            elif (self.units == "kHz"):
                if (units == "MHz"):
                    decloc += 3
                    postdec -= 6
                elif (units == "Hz"):
                    decloc -= 3
                    postdec += 3
                    pass
                pass
            pass
        if (postdec > self.suf):
            v //= 10 ** (postdec - self.suf)
            pass
        elif (postdec < self.suf):
            v *= 10 ** (self.suf - postdec)
            pass

        # Make sure to round as necessary
        return (v + (self.inc // 2)) // self.inc

    def conv_to_str(self, v):
        s = str(v * self.inc)
        while (len(s) < (self.len - self.numdec)):
            s = "0" + s
            pass
        s = s[0:self.len - self.numdec]
        s = s[0:self.pre] + "." + s[self.pre:] + self.units
        if (self.snddec != -1):
            s = s[0:self.snddec] + "." + s[self.snddec:]
            pass
        return s
    pass

class BIFixedFreq(BIFixed):
    def __init__(self, name="FixedFreq", width=10):
        BIFixed.__init__(self, name, width)
        return

    def getWidgetHandler(self, parent, t, num):
        h = BIFixed.getWidgetHandler(self, parent, t, num)
        return h

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "offset"):
            myh.offtie.append(fromh)
        elif (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
        elif (tie.tietype == "freqoff"):
            myh.offfreqtie.append(fromh)
        else:
            YType.newTie(self, myh, fromh, tie)
            pass
        if (myh.widget):
            self.redisplay(myh)
            pass
        return

    def getBits(self, h, num):
        t = h.data
        freq = self.get_raw(t, num)

        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (not off or off == "split"):
            return freq

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (bfreq):
            bfreq = int(bfreq)
            pass

        if (off == "smplx"):
            if bfreq:
                return bfreq
            return freq

        if not bfreq:
            return freq

        if (off == "+"):
            return bfreq + freq
        elif (off == "-"):
            return bfreq - freq
        else:
            print(("Warning: unknown offset: " + off))

        return freq

    def setBits(self, v, h, num):
        t = h.data
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (not off or off == "split"):
            self.set_raw(t, v, num)
            return
        if (off == "smplx"):
            # Ignore in simplex mode
            return

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (bfreq):
            bfreq = int(bfreq)
            pass

        if not bfreq:
            pass
        elif (off == "+"):
            v = v - bfreq
        elif (off == "-"):
            v = bfreq - v
        else:
            print(("Warning: unknown offset: " + off))
            pass
        self.set_raw(t, v, num)
        return

    def renumWidget(self, h, num):
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            offh = m
            if (off):
                break
            pass
        if (off):
            if (off == "smplx"):
                h.widget["state"] = "readonly"
            else:
                h.widget["state"] = "normal"
                pass
            pass

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (bfreq):
            h.lastbfreq = int(bfreq) * 10
            pass

        BIFixed.renumWidget(self, h, num)
        return

    def tieChanged(self, h, newtie):
        num = h.num
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            offh = m
            if (off):
                break
            pass
        if (off):
            if (off == "smplx"):
                h.widget["state"] = "readonly"
            else:
                h.widget["state"] = "normal"
                pass
            pass

        if newtie:
            BIFixed.renumWidget(self, h, num)
            return

        if ((not off) or (off == "split") or (off == "smplx")):
            BIFixed.renumWidget(self, h, num)
            pass

        t = h.data
        if (not t.data.config.doRptOffsets):
            BIFixed.renumWidget(self, h, num)
            return

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            bfreqh = m
            if (bfreq):
                break
            pass

        if (not bfreq):
            BIFixed.renumWidget(self, h, num)
            return

        bfreq = int(bfreq) * 10
        if bfreq != h.lastbfreq:
            h.lastbfreq = bfreq
            (o, freq) = t.data.config.rptoff.calcOffset(bfreq)
            offh.setSelect(o, num)
            offh.redisplay(offh)
            BIFixed.setBits(self, freq // 10, h, num)
            for m in h.offfreqtie:
                m.redisplay(m)
                pass
            pass
        self.renumWidget(h, num)
        return

    def matchName(self, c, string):
        if not string.startswith(self.name + "("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 self.name + " does not end with ')'")
        spec = string[len(self.name)+1:len(string)-1].split(",")
        if (len(spec) < 4) or (len(spec) > 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid %s specifier" % self.name)
        pre = c.toNum(spec[0])
        suf = c.toNum(spec[1])
        inc = c.toNum(spec[2])
        units = spec[3]
        snddec = -1
        width = self.width
        if (len(spec) >= 5):
            opts = spec[4].split(":")
            for opt in opts:
                o = opt.split("=", 1)
                if (o[0] == "sd"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "sd option requires value")
                    snddec = c.toNum(o[1])
                    if (snddec <= pre or snddec > (pre + suf)):
                        raise ParseException(c.filename, c.lineno,
                                             "sd option must be after pre"
                                             + " and before the end of the"
                                             + " number")
                    pass
                elif (o[0] == "w"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "w option requires value")
                    width = c.toNum(o[1])
                else:
                    raise ParseException(c.filename, c.lineno,
                                         ("Invalid %s option: %s"
                                          % (self.name, o[0])))
                pass
            pass
        b = self.newInst(string, width)
        b.setup(pre, suf, inc, units, snddec)
        return b

    def newInst(self, name, width):
        return BIFixedFreq(name=name, width=width)

    pass

# Like the above, but the value is stored in BCD format.
class BIBCDFixedFreq(BIFixedFreq):
    def __init__(self, name="BCDFixedFreq", width=10):
        BIFixedFreq.__init__(self, name, width)
        return

    def newInst(self, name, width):
        return BIBCDFixedFreq(name=name, width=width)

    def get_raw(self, t, num):
        v = t.data.get_bits(t.addr, num)
        # Convert from BCD to decimal
        d = 0
        mult = 1
        while (v > 0):
            d += (v % 16) * mult
            v //= 16
            mult *= 10
            pass
        d //= self.inc
        return d

    def set_raw(self, t, d, num):
        d *= self.inc
        # Convert from decimal to BCD
        v = 0
        mult = 1
        while (d > 0):
            v += (d % 10) * mult
            d //= 10
            mult *= 16
            pass
        t.data.set_bits(v, t.addr, num)
        return

    pass

class BICheckBox(YType):
    def __init__(self, name="CheckBox", reverse=False):
        YType.__init__(self, name)
        self.reverse = reverse
        pass

    def getWidgetHandler(self, parent, t, num):
        v = t.data.get_bits(t.addr, num)
        h = Handler(self.set, t, self)
        w = tkinter.tix.Checkbutton(parent, command=h.set)
        h.num = num
        h.widget = w
        if self.reverse:
            v = ~v & 1
            pass
        h.v = v
        if (v):
            w.select()
        else:
            w.deselect()
            pass
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        if self.reverse:
            v = ~v & 1
            pass
        h.v = v
        oldstate = h.widget["state"]
        if (oldstate != "normal"):
            h.widget["state"] = "normal"
            pass
        if (v):
            h.widget.select()
        else:
            h.widget.deselect()
            pass
        if (oldstate != "normal"):
            h.widget["state"] = oldstate
            pass
        pass

    def set(self, h):
        w = h.widget
        t = h.data
        if (h.v):
            h.v = 0
        else:
            h.v = 1
            pass
        v = h.v
        if self.reverse:
            v = ~v & 1
            pass
        t.data.set_bits(v, t.addr, h.num)
        h.modified()
        pass

    def getSelect(self, h, num):
        t = h.data
        v = t.data.get_bits(t.addr, num)
        if self.reverse:
            v = ~v & 1
            pass
        if (v):
            return '1'
        else:
            return '0'

    def setSelect(self, v, h, num, default=None):
        t = h.data
        if (v == "0"):
            v = 0
        elif (v == "1"):
            v = 1
        elif default is not None:
            try:
                v = int(default)
            except:
                return
            pass
        else:
            return
        if self.reverse:
            v = ~v & 1
            pass
        t.data.set_bits(v, t.addr, num)
        pass

    pass

class BIYaesuString(YType):
    # These are internal Yaesu string values for some radios, and a
    # clean set of characters to allow in general strings.
    string_conv = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ !\"\\$#%'()*+,-;/|:<=>?@[&]^_"
    space_char = 0x24


    def __init__(self, name="YaesuString", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        elif string.startswith(self.name + "("):
            if not string.endswith(")"):
                raise ParseException(c.filename, c.lineno,
                                     self.name + " does not end with ')'")
            spec = string[len(self.name)+1:len(string)-1].split(",")
            if (len(spec) != 1):
                raise ParseException(c.filename, c.lineno,
                                     "Invalid %s specifier" % self.name)
            width = c.toNum(spec[0])
            return self.newInst(string, width)
        return None

    def newInst(self, string, width):
        return BIYaesuString(string, width=width)

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must be a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_yaesu_string(self, data, addr, num):
        s = self.get_chars(data, addr, num)
        for i in range(0, len(s)):
            if (s[i] > 0x3f):
                s[i] = ' '
            else:
                s[i] = self.string_conv[s[i]]
                pass
            pass
        s = "".join(s)
        return s

    def set_yaesu_string(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] // 8
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                p = self.space_char
            else:
                p = self.string_conv.find(v[i])
                if (p < 0):
                    p = self.string_conv.find(v[i].upper())
                    pass
                if (p < 0):
                    p = self.space_char
                    pass
                pass
            self.set_char(data, p, addr, num, i)
            pass
        if (h):
            h.modified()
            pass
        pass

    def get_chars(self, data, addr, num):
        return data.get_bytes(addr, num)

    def set_char(self, data, p, addr, num, i):
        data.set_byte(p, addr, num, i)
        return

    def getWidgetHandler(self, parent, t, num):
        v = self.get_yaesu_string(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        h.v = v
        h.num = num
        w = tkinter.tix.Entry(parent, readonlybackground="tan")
        w["width"] = self.width
        h.widget = w
        w.bind("<KeyRelease>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        rewriteEntry(h.widget, self.get_yaesu_string(t.data, t.addr, num))
        pass

    def getSelect(self, h, num):
        t = h.data
        return self.get_yaesu_string(t.data, t.addr, num)

    def setSelect(self, v, h, num, default=None):
        t = h.data
        self.set_yaesu_string(v, t.data, t.addr, num, None)
        pass

    def set(self, h, event):
        w = h.widget
        t = h.data
        v = w.get()
        if (v == h.v):
            return
        cursor = w.index("insert")
        self.set_yaesu_string(v, t.data, t.addr, h.num, h)
        v = self.get_yaesu_string(t.data, t.addr, h.num)
        w.delete(0, 'end')
        w.insert(0, v)
        w.icursor(cursor)
        h.v = v
        pass
    pass

# Like above, but supports lower-case characters.  Still a
# non-standard encoding.
class BIYaesuLCString(BIYaesuString):
    string_conv = "0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,:;!\"#$%&'()*+-/=<>?@[?]^_\\{|}"
    space_char = 10

    def __init__(self, name="YaesuLCString", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def newInst(self, string, width):
        return BIYaesuLCString(string, width=width)

    pass

# Like above, but each character is 16 bits big endian
class BIYaesuLCString16(BIYaesuLCString):
    def __init__(self, name="YaesuLCString16", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def newInst(self, string, width):
        return BIYaesuLCString16(string, width=width)

    def get_chars(self, data, addr, num):
        bytes = data.get_bytes(addr, num)
        v = []
        for i in range(0, self.width):
            c = bytes[i * 2 + 1]
            if (c == 0xff):
                c = self.space_char
                pass
            v.append(c)
            pass
        return v

    def set_char(self, data, p, addr, num, i):
        p1 = 0x00
        if (p == self.space_char):
            p1 = 0xff
            p = 0xff
            pass
        data.set_byte(p1, addr, num, i * 2)
        data.set_byte(p, addr, num, i * 2 + 1)
        return

    pass

def convFromBCD(v):
    if (v >= 10) or (v < 0):
        return '0'
    return decimal_digits[v]

def convFromBCD(v):
    if (v >= 10) or (v < 0):
        return '0'
    return decimal_digits[v]

# Yaesu BCD format for frequency, see FT60-layout.txt
class BIBCDFreq(YType):
    def __init__(self):
        YType.__init__(self, "BCDFreq")
        # Our split value is in a separate location (FT-60R, etc.)
        self.splitsep = True
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "%s formats only support one"
                                + " location field" % self.name)
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "%s formats must have a zero bit"
                                 + " offset" % self.name)
        if (addr.entries[0][2] != 24):
            raise ParseException(c.filename, c.lineno,
                                 "%s formats must be 24 bits long" % self.name)
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "%s formats must have a"
                                 + " byte-multiple offset" % self.name)
        return True

    def get_bcd(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        add5 = s[i] >> 6
        v.append(convFromBCD(s[i] & 0xf))
        i += 1
        numbytes = 3
        while (i < numbytes):
            v.append(convFromBCD(s[i] >> 4))
            v.append(convFromBCD(s[i] & 0xf))
            i += 1
            pass
        if (add5 == 0x0):
            v.append('0.0')
        elif (add5 == 0x1):
            v.append('2.5')
        elif (add5 == 0x2):
            v.append('5.0')
        else:
            v.append('7.5')
            pass
        v.insert(3, '.')
        return "".join(v)
        pass

    def set_bcd(self, v, data, addr, num, h):
        vlen = len(v)
        add5 = v[vlen - 3]
        if (add5 < '2'):
            d = 0x0
        elif (add5 < '4'):
            d = 0x1 << 2
        elif (add5 < '7'):
            d = 0x2 << 2
        else:
            d = 0x3 << 2
            pass
        second = True
        i = 0
        for c in v[0:vlen - 3]:
            if c == '.':
                continue
            if (second):
                d <<= 4
                d |= decimal_digits.find(c)
                second = False
                data.set_byte(d, addr, num, i)
                i += 1
            else:
                d = decimal_digits.find(c)
                second = True
                pass
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_bcd(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        w = tkinter.tix.Entry(parent, readonlybackground="tan")
        w['width'] = 8
        h.widget = w
        h.num = num

        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def getStr(self, h, num):
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                pass
            else:
                freq = None
                for m in h.basefreqtie:
                    freq = m.getValue(num)
                    if (freq):
                        break
                    pass
                if (freq):
                    freq = freq[0:7] + freq[8]
                    freq = float(freq)
                    if (off != 'smplx'):
                        # It's a + or - offset, add/sub the offset frequency
                        o = None
                        for m in h.offfreqtie:
                            if (m.type.__class__ == Enum):
                                # We don't send offset values to enums.
                                continue
                            # Use getSelect, not getValue, because getSelect
                            # carries Mhz, kHz, etc.
                            o = m.getSelect(num)
                            if (o):
                                break
                            pass
                        if (o):
                            # Split out trailing MHz, Khz, Hz
                            i = 0
                            for c in o:
                                if (not c.isdigit() and c != '.'):
                                    break
                                i += 1
                                pass
                            sfx = o[i:]
                            o = o[0:i]
                            offfreq = float(o)
                            if (sfx == "kHz"):
                                offfreq //= 1000.0
                            elif (sfx == "Hz"):
                                offfreq //= 1000000.0
                                pass
                            pass
                        else:
                            offfreq = 0.0
                            pass
                        if (off == '+'):
                            freq += offfreq
                        elif (off == '-'):
                            freq -= offfreq
                        else:
                            print(("Warning: unknown offset: " + off))
                            pass
                        pass
                    v = str(freq)
                    (pre, post) = v.split(".")
                    if (len(pre) > 4):
                        pre = 999
                        post = 999
                        pass
                    if (len(post) > 5):
                        post = post[0:4]
                        pass
                    while (len(pre) < 3):
                        pre = "0" + pre
                        pass
                    while (len(post) < 4):
                        post += "0"
                        pass
                    v = pre + "." + post[0:3] + "." + post[3]

                    return v;
                pass
            pass
        t = h.data
        return self.get_bcd(t.data, t.addr, num)

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "readonly"
                pass
            pass

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (bfreq):
            h.lastbfreq = getHz(bfreq, "", 0)
            pass

        h.num = num
        v = self.getStr(h, num)
        rewriteEntry(h.widget, v)
        pass

    def tieChanged(self, h, newtie):
        num = h.num
        YType.renumWidget(self, h, num)
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            offh = m
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "readonly"
                pass
            pass

        if newtie:
            self.renumWidget(h, num)
            return

        if ((not off) or (off == "split") or (off == "smplx")):
            self.renumWidget(h, num)
            pass

        t = h.data
        if (not t.data.config.doRptOffsets):
            self.renumWidget(h, num)
            return

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            bfreqh = m
            if (bfreq):
                break
            pass

        if (not bfreq):
            v = self.getStr(h, num)
            rewriteEntry(h.widget, v)
            return

        bfreq = getHz(bfreq, "", 0)
        if bfreq != h.lastbfreq:
            h.lastbfreq = bfreq
            (o, freq) = t.data.config.rptoff.calcOffset(bfreq)
            offh.setSelect(o, num)
            offh.redisplay(offh)
            for m in h.offfreqtie:
                m.setSelect(str(freq)+"Hz", num)
                m.redisplay(m)
                pass
            pass

        v = self.getStr(h, num)
        rewriteEntry(h.widget, v)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "offset"):
            myh.offtie.append(fromh)
        elif (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        elif (tie.tietype == "freqoff"):
            myh.offfreqtie.append(fromh)
            pass
        else:
            YType.newTie(self, myh, fromh, tie)
            pass
        if myh.widget:
            self.redisplay(myh)
            pass
        return

    def getValue(self, h, num):
        t = h.data
        return self.get_bcd(t.data, t.addr, num)

    def getSelect(self, h, num):
        t = h.data
        # Note that we pad it out to Hz for copy/paste, for compatability
        return self.getStr(h, num) + "00"

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert") or (event.keysym == "space")):
            return "break" # Don't allow deletions
        if (event.keysym == 'period'):
            return "break" # Ignore typed '.'
        if (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= 7):
            return "break" # Past the end of the entry
        if (cursor == 3):
            w.icursor(cursor + 1) # Skip over the '.'
            return "break"

        c = event.keysym
        if (c not in decimal_digits):
            return "break" # Ignore everything but numbers

        if (cursor == 6):
            # Last digit can only be 0 or 5
            if (c < '2'):
                c = '0.0'
            elif (c < '4'):
                c = '2.5'
            elif (c < '7'):
                c = '5.0'
            else:
                c = '7.5'
                pass
            pass

        s = w.get()
        if (s[cursor] != c):
            for m in c:
                w.delete(cursor)
                pass
            w.insert(cursor, c)
            t = h.data
            self.set_bcd(w.get(), t.data, t.addr, h.num, h)
            pass
        if (cursor == 2):
            w.icursor(cursor + 2) # Skip over the '.'
        else:
            w.icursor(cursor + 1)
        return "break"

    def setSelect(self, v, h, num, default=None):
        firstc = False
        c2 = [ ]
        for c in v:
            if ((c != '.') and (c not in decimal_digits)):
                return
            if (c == '.'): # Cut off the last '.', if present
                if (firstc):
                    continue
                firstc = True;
                pass
            c2.append(c)
            pass

        v = "".join(c2)

        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                pass
            else:
                bfreq = None
                for m in h.basefreqtie:
                    bfreq = m.getValue(num)
                    if (bfreq):
                        break
                    pass
                if (bfreq):
                    bfreq = bfreq[0:7] + bfreq[8]
                    bfreq = float(bfreq)
                    if (off != 'smplx'):
                        # It's a + or - offset, add/sub the offset frequency
                        o = None
                        for m in h.offfreqtie:
                            if (m.type.__class__ == Enum):
                                # We don't send offset values to enums.
                                continue
                            o = m
                            break

                        if (o):
                            freq = float(v)
                            if (off == '+'):
                                offfreq = freq - bfreq
                            elif (off == '-'):
                                offfreq = bfreq - freq
                            else:
                                print(("Warning: unknown offset: " + off))
                                return

                            o.setSelect(str(offfreq) + "MHz", num)
                            return
                        pass
                    pass
                pass
            pass

        # If the split value (TX) is in a separate place, or there is not
        # an offset setting (like for RX) or if the offset setting is split,
        # then write the value.
        if (self.splitsep or (not off) or (off == "split")):
            t = h.data
            self.set_bcd(v, t.data, t.addr, num, None)
            pass
        pass
    pass

hex_digits = "0123456789ABCDEF "
def convFromHex(v):
    if (v == 0xff):
        return ' '
    if (v >= 16) or (v < 0):
        return '0'
    return hex_digits[v]

# Different style of BCD, look in VX-7R.layout for info
class BIBCDFreq2(BIBCDFreq):
    def __init__(self):
        YType.__init__(self, "BCDFreq2")
        # Our split location is shared with the offset value
        self.splitsep = False
        pass

    def get_bcd(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        numbytes = 3
        while (i < numbytes):
            v.append(convFromBCD(s[i] >> 4))
            v.append(convFromBCD(s[i] & 0xf))
            i += 1
            pass

        # The bottom two digits is either 0.0, 2.5, 5.0, or 7.5, the 0 or 5
        # at the end is derived.
        if (v[5] == '2' or v[5] == '7'):
            v.append('.5')
        else:
            v.append('.0')
            pass
        v.insert(3, '.')
        return "".join(v)

    def set_bcd(self, v, data, addr, num, h):
        # Note that the .5 or .0 at the end is not relevant, that can be
        # derived from the digit before, so we don't process that
        second = False
        i = 0
        for c in v[0:len(v) - 2]:
            if c == '.':
                continue
            if (second):
                d <<= 4
                d |= decimal_digits.find(c)
                second = False
                data.set_byte(d, addr, num, i)
                i += 1
                pass
            else:
                d = decimal_digits.find(c)
                second = True
                pass
            pass
        if (h):
            h.modified()
            pass
        pass

class BIHexDigits(YType):
    def __init__(self):
        YType.__init__(self, "HexDigits")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigit formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_hex(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        numbytes = addr.entries[0][2] // 8
        while (i < numbytes):
            v.append(convFromHex(s[i]))
            i += 1
            pass
        return "".join(v)
        pass

    def set_hex(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] // 8

        vlen = len(v)
        second = False
        i = 0
        for c in v:
            if (c == ' '):
                d = 0xff
            else:
                d = hex_digits.find(c)
            data.set_byte(d, addr, num, i)
            i += 1
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_hex(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        h.numbytes = t.addr.entries[0][2] // 8
        w = tkinter.tix.Entry(parent, readonlybackground="tan")
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = self.get_hex(t.data, t.addr, num)
        rewriteEntry(h.widget, v)
        pass

    def getSelect(self, h, num):
        t = h.data
        return self.get_hex(t.data, t.addr, num)

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert")):
            return "break" # Don't allow deletions
        if (event.keysym == "space"):
            event.keysym = ' '
        elif (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= h.numbytes):
            return "break" # Past the end of the entry

        c = event.keysym.upper()
        if (c != ' ' and c not in hex_digits):
            return "break" # Ignore everything but numbers and space

        t = h.data
        s = w.get()
        if (s[cursor] != c):
            w.delete(cursor)
            w.insert(cursor, c)
            self.set_hex(w.get(), t.data, t.addr, h.num, h)
            pass
        w.icursor(cursor + 1)
        return "break"

    def setSelect(self, v, h, num, default=None):
        for c in v:
            if (c not in decimal_digits):
                return
            pass

        t = h.data
        self.set_hex(v, t.data, t.addr, num, None)
        pass
    pass

class MenuAndButton(tkinter.tix.Menubutton):
    def __init__(self, parent):
        tkinter.tix.Menubutton.__init__(self, parent)
        self.menu = tkinter.tix.Menu(self)
        self['menu'] = self.menu
        pass

    def add_command(self, name, handler):
        self.menu.add_command(label=name, command=handler)
        pass

    def set_label(self, label):
        self["text"] = label
    pass

class EnumEntry:
    def __init__(self, value, str):
        self.value = value
        self.str = str
        return
    pass

class Enum(YType):
    def __init__(self, name):
        YType.__init__(self, name)
        self.entries = []
        pass

    def add(self, c, v):
        if (v[0] == "endenum"):
            c.addEnum(self)
            return

        if (len(v) != 2):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for enum")

        n = c.toNum(v[0])
        for e in self.entries:
            if (e.value == n):
                raise ParseException(c.filename, c.lineno,
                                     "Enum value already used")
            if (e.str == v[1]):
                raise ParseException(c.filename, c.lineno,
                                     "Enum string already used")
            pass
        self.entries.append(EnumEntry(n, v[1]))
        pass

    def getWidgetHandler(self, parent, t, num):
        toph = Handler(None, t, self)
        toph.widget = MenuAndButton(parent)
        toph.num = num
        v = t.data.get_bits(t.addr, num)
        toph.widget.set_label("---")
        for e in self.entries:
            h = Handler(self.set, e, self)
            h.toph = toph
            toph.widget.add_command(e.str, h.set)
            if (v == e.value):
                toph.widget.set_label(e.str)
                pass
            pass
        return toph

    def set(self, h):
        e = h.data
        h.toph.widget.set_label(e.str)
        t = h.toph.data
        t.data.set_bits(e.value, t.addr, h.toph.num)
        h.toph.modified()
        pass

    def renumWidget(self, toph, num):
        YType.renumWidget(self, toph, num)
        toph.num = num
        t = toph.data
        v = t.data.get_bits(t.addr, num)
        found = False
        oldstate = toph.widget["state"]
        if (oldstate != "normal"):
            toph.widget["state"] = "normal"
            pass
        for e in self.entries:
            if (v == e.value):
                found = True
                toph.widget.set_label(e.str)
                break
            pass
        if (not found):
            toph.widget.set_label("---")
            pass
        if (oldstate != "normal"):
            toph.widget["state"] = oldstate
            pass
        pass

    def getSelect(self, h, num):
        t = h.data
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            if (v == e.value):
                return e.str.replace(" ", "")
            pass
        pass

    def setSelect(self, v, h, num, default=None):
        t = h.data
        for e in self.entries:
            if (v == e.str.replace(" ", "")):
                t.data.set_bits(e.value, t.addr, num)
                return
            pass
        if default is None:
            return
        for e in self.entries:
            if (default == e.str.replace(" ", "")):
                t.data.set_bits(e.value, t.addr, num)
                return
            pass
        pass

    pass

class SListEntry:
    def __init__(self, value, str, pos):
        self.value = value
        self.str = str
        self.pos = pos
        return
    pass

class SList(YType):
    def __init__(self, name):
        YType.__init__(self, name)
        self.entries = []
        pass

    def add(self, c, v):
        if (v[0] == "endslist"):
            c.addEnum(self)
            return

        if (len(v) != 2):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for enum")

        n = c.toNum(v[0])
        i = 0
        for e in self.entries:
            if (e.value == n):
                raise ParseException(c.filename, c.lineno,
                                     "List value already used")
            if (e.str == v[1]):
                raise ParseException(c.filename, c.lineno,
                                     "List string already used")
            i += 1
            pass
        self.entries.append(SListEntry(n, v[1], i))
        pass

    def getWidgetHandler(self, parent, t, num):
        h = Handler(self.set, t, self)
        h.widget = tkinter.tix.ScrolledListBox(parent, scrollbar='auto')
        h.widget.listbox['selectmode'] = "single"
        h.widget.listbox['activestyle'] = "dotbox"
        # If we export the selection, then the listbox loses
        # selection whenever something else gets it.
        h.widget.listbox['exportselection'] = "false"
        h.widget.listbox.bind("<<ListboxSelect>>", h.set_event)
        h.num = num
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            h.widget.listbox.insert(tkinter.tix.END, e.str)
            if (e.value == v):
                h.widget.listbox.selection_set(e.pos)
                h.widget.listbox.see(e.pos)
                pass
            pass
        return h

    def set(self, h, event):
        t = h.data
        pos = h.widget.listbox.curselection()
        if (len(pos) < 1):
            return
        pos = int(pos[0])
        e = self.entries[pos]
        t.data.set_bits(e.value, t.addr, h.num)
        pass

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        found = False
        oldstate = h.widget["state"]
        if (oldstate != "normal"):
            h.widget["state"] = "normal"
            pass
        for e in self.entries:
            if (v == e.value):
                h.widget.listbox.selection_set(e.pos)
                break
            pass
        if (oldstate != "normal"):
            h.widget["state"] = oldstate
            pass
        pass

    def getSelect(self, h, num):
        t = h.data
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            if (v == e.value):
                return e.str.replace(" ", "")
            pass
        pass

    def setSelect(self, v, h, num, default=None):
        t = h.data
        for e in self.entries:
            if (v == e.str.replace(" ", "")):
                t.data.set_bits(e.value, t.addr, num)
                return
            pass
        if default is None:
            return
        for e in self.entries:
            if (default == e.str.replace(" ", "")):
                t.data.set_bits(e.value, t.addr, num)
                return
            pass
        pass

    pass

###############################################################################
#
#
#
###############################################################################
class Tie:
    def __init__(self, value, tietype):
        self.tietype = tietype
        self.value = value
        self.widget = None
        return

    def setWidget(self, w):
        self.widget = w
        return

    def redisplay(self, h):
        self.widget.redisplay(h)
        return

    def tieChanged(self, h, newtie):
        self.widget.tieChanged(h, newtie)
    pass

class TabEntry:
    def __init__(self, name, pos, addr, type, data, tielist_str, cutpaste,
                 specials):
        self.name = name
        self.pos = pos
        nn = self.name.replace("\n", "")
        nn = nn.replace(" ", "")
        nn = nn.replace("\t", "")
        self.nsname = nn
        self.addr = addr
        self.type = type
        self.data = data
        self.specials = specials

        # The list of Tie items that we are tied to.
        self.tielist = tielist_str

        self.cutpaste = cutpaste

        self.displayheader = True
        pass

    def getWidgetHandler(self, parent, num):
        return self.type.getWidgetHandler(parent, self, num)

    def renumWidget(self, h, num):
        self.type.renumWidget(h, num)
        pass

    def redisplay(self, h):
        self.type.redisplay(h)
        return

    def tieChanged(self, h, newtie):
        self.type.tieChanged(h, newtie)
        return

    def getSelect(self, h, num):
        v = self.type.getSelect(h, num)
        if (v is None):
            v = ""
        return (self.nsname + "=" + v)

    def setSelect(self, h, num, vhash):
        if "default" in self.specials:
            defval = self.specials["default"]
        else:
            defval = None
            pass

        if (self.nsname in vhash):
            v = vhash[self.nsname]
            del vhash[self.nsname]
            self.type.setSelect(v, h, num, default=defval)
            pass
        elif "tone" in self.specials:
            tt = self.specials["tone"]
            if tt == "both":
                v = None
                if "TxToneMode" in vhash:
                    found = True
                    r = vhash["TxToneMode"]
                    del vhash["TxToneMode"]
                    if (r == "None"):
                        v = "None"
                    elif (r == "Tone"):
                        v = "Tone"
                    elif (r == "DCS"):
                        v = "DCode"
                        pass
                    pass
                if "RxToneMode" in vhash:
                    found = True
                    r = vhash["RxToneMode"]
                    del vhash["RxToneMode"]
                    if v is None:
                        v = "None"
                        pass
                    if (r == "Tone"):
                        if (v == "Tone"):
                            v = "T-SQL"
                        elif (v == "DCode"):
                            v = "TDCS"
                            pass
                        pass
                    elif (r == "DCS"):
                        if (v == "Tone"):
                            v = "DTone"
                        elif (v == "DCode"):
                            v = "DCS"
                            pass
                        pass

                    pass
                if v:
                    self.type.setSelect(v, h, num, default=defval)
                    pass
                pass
            elif tt == "rx":
                if "ToneMode" in vhash:
                    v = vhash["ToneMode"]
                    # Don't delete, tx tone might need it
                    if ((v == "T-SQL") or (v == "DTone")):
                        v = "Tone"
                    elif ((v == "DCS") or (v == "TDCS")):
                        v = "DCS"
                    else:
                        v = "None"
                        pass
                    self.type.setSelect(v, h, num, default=defval)
                    pass
                pass
            elif tt == "tx":
                if "ToneMode" in vhash:
                    v = vhash["ToneMode"]
                    # Don't delete, rx tone might need it
                    if ((v == "T-SQL") or (v == "Tone") or (v == "TDCS")):
                        v = "Tone"
                    elif ((v == "DCS") or (v == "DCode") or (v == "DTone")):
                        v = "DCS"
                    else:
                        v = "None"
                        pass
                    self.type.setSelect(v, h, num, default=defval)
                    pass
                pass
            pass
        elif defval is not None:
            self.type.setSelect(defval, h, num)
        return

    pass

class TabBase:
    def __init__(self, name, base):
        self.name = name
        self.base = base

        # A list of TabEntry objects
        self.entries = []
        return

    def addItem(self, c, name, addr, type, opts):
        type.checkAddrOk(c, addr)

        ties = []
        cutpaste = True
        specials = { }
        for i in opts:
            s = i.split('=', 1)
            if len(s) != 2:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option, no '=': " + i)
            if (s[0] == "tie"):
                ties.append(Tie(s[1], "normal"))
            elif s[0].startswith("tie("):
                if not s[0].endswith(")"):
                    raise ParseException(c.filename, c.lineno,
                                         "tie type does not end with ')'")
                tietype = s[0][4:len(s[0])-1]
                ties.append(Tie(s[1], tietype))
            elif (s[0] == "cutpaste"):
                if (s[1].lower() == "true"):
                    cutpaste = True
                elif (s[1].lower() == "false"):
                    cutpaste = False
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "cutpaste takes true or false")
            elif (s[0] == "tone"):
                if (s[1] == "rx"):
                    specials["tone"] = "rx"
                elif (s[1] == "tx"):
                    specials["tone"] = "tx"
                elif (s[1] == "both"):
                    specials["tone"] = "both"
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "tone takes rx, tx, or both")
                pass
            elif (s[0] == "default"):
                specials["default"] = s[1]
                pass
            else:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option: " + i);
            pass

        self.entries.append(TabEntry(name, len(self.entries), addr,
                                     type, c.filedata, ties, cutpaste,
                                     specials))
        return

    def finalize(self, c):
        for i in self.entries:
            for t in i.tielist:
                found = False
                for j in self.entries:
                    if (j.name == t.value):
                        t.setWidget(j)
                        found = True
                        break
                    pass
                if (not found):
                    raise ParseException(c.filename, c.lineno,
                                         ("tie entry for '" + t.value
                                          +"' not found"))
                pass
            pass
        return

    pass

class List(TabBase):
    """This is a list widget rework to make an HList that only has the
    items being displayed as list entries.  If you add the entire lists and
    scroll it and there are a thousand entries, a standard scrolled hlist
    is too slow because of the tens of thousands of widgets created.  So
    this class only creates widgets for the dislayed amount, then it
    redoes what is in the widgets based upon the scroll position."""
    def __init__(self, name, length, labels, base=0):
        TabBase.__init__(self, name, base)

        # Total length of elements in the list
        self.length = length

        # If supplied, these will be applied to as many list entries
        # as possible
        self.labels = labels

        # Number of lines currently displayed
        self.numdisplines = 0

        # Number of the first displayed line
        self.firstdispline = 0

        # A list of handlers for each displayed row
        self.handlerlists = []
        pass

    def add(self, c, v):
        if (v[0] == "endlist"):
            self.finalize(c)
            c.addList(self)
            return
        if (len(v) < 3):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for list entry")
        self.addItem(c, v[0], Address(c, v[1], base=self.base),
                     c.findType(v[2]), v[3:])
        pass

    def bindWidget(self, widget):
        widget.bind("<MouseWheel>", self.Wheel)
        widget.bind("<Down>", self.lineDown)
        widget.bind("<Up>", self.lineUp)
        widget.bind("<Next>", self.pageDown)
        widget.bind("<Prior>", self.pageUp)
        if (self.winsys == "x11"):
            widget.bind("<Button-4>", self.ButtonUpWheel)
            widget.bind("<Button-5>", self.ButtonDownWheel)
            pass
        pass

    def setup(self, top):
        try:
            self.winsys = top.tk.eval("return [ tk windowingsystem ]")
            pass
        except:
            # Assume x11
            self.winsys = "x11"
            pass

        self.xscroll = tkinter.tix.Scrollbar(top, orient=tkinter.tix.HORIZONTAL)
        self.yscroll = tkinter.tix.Scrollbar(top, orient=tkinter.tix.VERTICAL)
        self.list = tkinter.tix.HList(top, header=1, columns=len(self.entries) + 1,
                              itemtype="text", selectforeground="black",
                              selectbackground="beige",
                              yscrollcommand=self.y_scrolled,
                              xscrollcommand=self.xscroll.set)
        self.xscroll['command'] = self.list.xview
        self.yscroll['command'] = self.y_move
        self.xscroll.pack(side=tkinter.tix.BOTTOM, fill=tkinter.tix.X)
        self.yscroll.pack(side=tkinter.tix.RIGHT, fill=tkinter.tix.Y)

        self.list.selection_handle(self.selection_request)

        self.first_select = -1
        self.last_select = -1
        self.last_selection = ""
        self.last_selection_len = 0
        self.list.bind("<Button-1>", self.Button1)
        self.list.bind("<Shift-Button-1>", self.SButton1)
        self.list.bind("<Control-Button-1>", self.CButton1)
        self.list.bind("<Button-2>", self.Button2)
        self.list.bind("<Button-3>", self.Button3)

        self.list.bind("<Map>", self.mapped)

        self.bindWidget(self.list)
        self.bindWidget(self.xscroll)
        self.bindWidget(self.yscroll)

        i = 1
        for e in self.entries:
            e.column = i
            if (e.type.displayheader):
                self.list.header_create(i, text=e.name)
                self.list.column_width(i, "")
                pass
            i += 1
            pass

        self.list.pack(side=tkinter.tix.LEFT, fill=tkinter.tix.BOTH, expand=1)
        pass

    def mapped(self, event=None):
        self.list.focus_set()
        return

    def selection_request(self, offset, length):
        if (self.first_select < 0):
            return ""
        offset = int(offset)
        length = int(length)
        if (offset == 0):
            s = ""
            # Set up handlers, enough so the ties work for cutting/pasting
            handlers = []
            for e in self.entries:
                handlers.append(Handler(None, e, e.type))
                pass
            for e in self.entries:
                for t in e.tielist:
                    handlers[e.pos].addTie(handlers[t.widget.pos], t)
                    pass
                pass
            for i in range(self.first_select, self.last_select + 1):
                if (s):
                    s += "\n"
                    pass
                first = True
                for e in self.entries:
                    if (not e.cutpaste):
                        continue
                    if (not first):
                        s += " "
                    else:
                        first = False
                        pass
                    s += e.getSelect(handlers[e.pos], i)
                    pass
                pass
            self.last_selection = s
            self.last_selection_len = len(s)
            pass
        if (offset > self.last_selection_len):
            return ""
        elif ((offset + length) <= self.last_selection_len) :
            return self.last_selection[offset:offset + length]
        else:
            s = self.last_selection[offset:]
            self.last_selection = ""
            self.last_selection_len = 0
            return s
        return ""

    def redoSelection(self):
        if ((self.last_select < self.firstdispline)
            or (self.first_select >= self.firstdispline + self.numdisplines)):
            # Nothing to see
            self.list.selection_clear()
            return

        if (self.first_select <= self.firstdispline):
            pos1 = 0
        else:
            pos1 = self.first_select - self.firstdispline
            pass

        end = self.firstdispline + self.numdisplines - 1
        if (self.last_select >= end):
            pos2 = self.numdisplines - 1
        else:
            pos2 = self.last_select - self.firstdispline
            pass

        self.list.selection_clear()
        self.list.selection_set(pos1, pos2)
        self.list.selection_own()

        # For some reason, for me, the first one doesn't Actually cause
        # the display to change, doing it twice seems to fix the problem.
        self.list.selection_clear()
        self.list.selection_set(pos1, pos2)
        self.list.selection_own()
        pass

    def Button1(self, event):
        self.list.focus_set()
        line = int(self.list.nearest(event.y))
        self.first_select = self.firstdispline + line
        self.last_select = self.firstdispline + line
        self.redoSelection()
        return "break"

    def SButton1(self, event):
        if (self.first_select < 0):
            return self.Button1(event)
        line = int(self.list.nearest(event.y))
        pos = line + self.firstdispline
        if (pos <= self.first_select):
            self.first_select = pos
        else:
            self.last_select = pos
            pass
        self.redoSelection()
        return "break"

    def CButton1(self, event):
        return "break"

    def Button2(self, event):
        linenum = int(self.list.nearest(event.y)) + self.firstdispline
        s = self.list.selection_get()
        lines = s.split("\n")
        for l in lines:
            if (linenum >= self.length):
                return
            vhash = {}
            for vp in l.split():
                v = vp.split("=")
                if (len(v) != 2):
                    continue
                vhash[v[0]] = v[1]
                pass
            # Set up handlers, enough so the ties work for cutting/pasting
            handlers = []
            for e in self.entries:
                handlers.append(Handler(None, e, e.type))
                pass
            for e in self.entries:
                for t in e.tielist:
                    handlers[e.pos].addTie(handlers[t.widget.pos], t)
                    pass
                pass
            for e in self.entries:
                if (e.cutpaste):
                    e.setSelect(handlers[e.pos], linenum, vhash)
                    pass
                pass
            linenum += 1
            pass
        self.redisplay()
        return "break"

    def Button3(self, event):
        self.first_select = -1
        self.last_select = -1
        self.redoSelection()
        return "break"

    def Wheel(self, event):
        self.y_move("scroll", -(event.delta // 20), "units")
        return

    def ButtonUpWheel(self, event):
        event.delta = 120
        self.Wheel(event);
        return

    def ButtonDownWheel(self, event):
        event.delta = -120
        self.Wheel(event);
        return

    def y_scrolled(self, a, b):
        b = float(b)
        if (self.numdisplines < self.length) and (b >= 1.0):
            self.add_one_line()
        elif ((self.numdisplines > 0)
              and (b < (1.0 - (1.0 / float(self.numdisplines))))):
            self.del_one_line()
        else:
            pct = float(self.numdisplines) / float(self.length)
            first = float(self.firstdispline) / float(self.length)
            self.yscroll.set(first, first + pct)
            pass
        self.redoSelection()
        pass

    def pageDown(self, event=None):
        self.y_move("scroll", 1, "pages")
        return "break"

    def pageUp(self, event=None):
        self.y_move("scroll", -1, "pages")
        return "break"

    def lineDown(self, event=None):
        self.y_move("scroll", 1, "units")
        return "break"

    def lineUp(self, event=None):
        self.y_move("scroll", -1, "units")
        return "break"

    def y_move(self, a, b=None, c=None):
        if (a == "scroll"):
            if (c == "units"):
                if (int(b) < 0):
                    if (self.firstdispline > 0):
                        self.firstdispline -= 1
                        self.redisplay()
                        pass
                    pass
                else:
                    if ((self.firstdispline + self.numdisplines)
                        < self.length):
                        self.firstdispline += 1
                        self.redisplay()
                        pass
                    pass
                pass
            elif (c == "pages"):
                if (int(b) < 0):
                    if (self.firstdispline > (self.numdisplines - 1)):
                        self.firstdispline -= self.numdisplines - 1
                        self.redisplay()
                    elif (self.firstdispline > 0):
                        self.firstdispline = 0
                        self.redisplay()
                        pass
                    pass
                else:
                    if (self.firstdispline + (2 * self.numdisplines) - 1
                        <= self.length):
                        self.firstdispline += self.numdisplines - 1
                        self.redisplay()
                    elif (self.firstdispline + self.numdisplines
                          <= self.length):
                        self.firstdispline = self.length - self.numdisplines
                        self.redisplay()
                        pass
                    pass
                pass
        elif (a == "moveto"):
            pct = float(b)
            fl = int(pct * float(self.length))
            if ((fl != self.firstdispline)
                and (fl >= 0)
                and ((fl + self.numdisplines) <= self.length)):
                self.firstdispline = fl
                self.redisplay()
                pass
            pass
        pass

    def redisplay(self):
        i = 0
        for wl in self.handlerlists:
            pos = i + self.firstdispline
            if (pos < len(self.labels)):
                text = self.labels[pos]
            else:
                text = str(pos + 1)
            pass
            self.list.item_configure(i, 0, text=text)
            for e in self.entries:
                e.renumWidget(wl[e.pos], i + self.firstdispline)
                pass
            i += 1
            pass
        pass

    def add_one_line(self):
        handlers = []
        pos = self.firstdispline + self.numdisplines
        if (pos >= self.length):
            return
        if (pos < len(self.labels)):
            text = self.labels[pos]
        else:
            text = str(pos + 1)
            pass
        self.list.add(self.numdisplines, text=text)
        for e in self.entries:
            h = e.getWidgetHandler(self.list, pos)
            h.ename = e.name
            if (h.widget):
                self.bindWidget(h.widget)
                self.list.item_create(self.numdisplines, e.column,
                                      itemtype=tkinter.tix.WINDOW,
                                      window=h.widget)
                pass
            handlers.append(h)
            pass
        for e in self.entries:
            for t in e.tielist:
                handlers[e.pos].addTie(handlers[t.widget.pos], t)
                pass
            pass
        self.handlerlists.append(handlers)
        self.numdisplines += 1
        pass

    def del_one_line(self):
        if (self.numdisplines < 0):
            return
        self.numdisplines -= 1

        # FIXME - does this break all the pointer cycles?
        del self.handlerlists[self.numdisplines]
        self.list.delete_entry(self.numdisplines)
        pass

    pass

class Tab(TabBase):
    def __init__(self, name, base=0):
        TabBase.__init__(self, name, base)
        pass

    def add(self, c, v):
        if (v[0] == "endtab"):
            self.finalize(c)
            c.addTab(self)
            return
        if (len(v) < 3):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for tab entry");

        self.addItem(c, v[0], Address(c, v[1], base=self.base),
                     c.findType(v[2]), v[3:])
        return

    def bindWidget(self, widget):
        widget.bind("<MouseWheel>", self.Wheel)
        if (self.winsys == "x11"):
            widget.bind("<Button-4>", self.ButtonUpWheel)
            widget.bind("<Button-5>", self.ButtonDownWheel)
            pass
        pass

    def Wheel(self, event):
        self.list.hlist.yview("scroll", -(event.delta // 20), "units")
        return

    def ButtonUpWheel(self, event):
        event.delta = 120
        self.Wheel(event);
        return

    def ButtonDownWheel(self, event):
        event.delta = -120
        self.Wheel(event);
        return

    def setup(self, top):
        try:
            self.winsys = top.tk.eval("return [ tk windowingsystem ]")
            pass
        except:
            # Assume x11
            self.winsys = "x11"
            pass

        self.list = tkinter.tix.ScrolledHList(top, scrollbar="auto",
                                      options="hlist.header 1"
                                      + " hlist.columns 2"
                                      + " hlist.itemtype text"
                                      + " hlist.selectForeground black"
                                      + " hlist.selectBackground beige")
        self.list.hlist.header_create(0, text="Name")
        self.list.hlist.header_create(1, text="Value")
        self.list.hlist.column_width(0, "")
        self.list.hlist.column_width(1, "")
        self.bindWidget(self.list)
        self.bindWidget(self.list.hlist)
        self.bindWidget(self.list.hsb)
        self.bindWidget(self.list.vsb)

        i = 0
        handlers = []
        for e in self.entries:
            e.key = i
            self.list.hlist.add(i, text=e.name)
            h = e.getWidgetHandler(self.list.hlist, i)
            if (h.widget):
                self.list.hlist.item_create(i, 1, itemtype=tkinter.tix.WINDOW,
                                            window=h.widget)
                self.bindWidget(h.widget)
                pass
            handlers.append(h)
            i += 1
            pass
        for e in self.entries:
            for t in e.tielist:
                handlers[e.pos].addTie(handlers[t.widget.pos], t)
                pass
            pass

        self.list.pack(side=tkinter.tix.LEFT, fill=tkinter.tix.BOTH, expand=1)
        pass

    pass

###############################################################################
#
#
#
###############################################################################
quote_hash = {"n" : "\n",
              "t" : "\t",
              "r" : "\r" }

def unquote(s):
    inquote = False
    v = []
    for c in s:
        if (inquote):
            if (c in quote_hash):
                v.append(quote_hash[c])
            else:
                v.append(c);
                pass
            inquote = False
            pass
        elif (c == '\\'):
            inquote = True
            pass
        else:
            v.append(c)
            pass
        pass
    return "".join(v)

class RadioConfig:
    def __init__(self, filename, filedata, parent=None, name=None):
        self.filename = filename
        self.filedata = filedata
        self.parent = parent
        self.name = name
        self.curr = None
        self.toplevel = []
        if (parent):
            self.types = self.parent.types
            self.infile = parent.infile
            self.lineno = parent.lineno
        else:
            self.types = [ BIBCDFreq(),
                           BIBCDFreq2(),
                           BICheckBox(),
                           BICheckBox(name="RCheckBox", reverse=True),
                           BIYaesuString(),
                           BIYaesuLCString(), BIYaesuLCString16(),
                           BIString(), YType("Empty"),
                           BIHexDigits(), BIInt(), BIHex(), BIFixed(),
                           BIFixedFreq(), BIBCDFixedFreq(),
                           BISpecial(), BISpecial857A(),
                           BISpecial857B(), BISpecialTMV71(), BISetToZero() ]
            self.infile = open(filename, "r")
            self.lineno = LineNum()
            pass
        try:
            while True:
                l = self.infile.readline();
                if (not l):
                    break
                self.lineno.inc()
                if l[0] == '#':
                    continue
                v = self.splitup_line(l);
                if (not v):
                    continue
                if (v[0] == "endmulti"):
                    if (not self.parent):
                        raise ParseException(self.filename, self.lineno,
                                             "got endmulti, but not in multi")
                    self.parent.addMulti(self)
                    return

                self.parseLine(v)
                pass
            pass
        except Exception as e:
            exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
            self.infile.close()
            raise exceptionType(exceptionValue).with_traceback(exceptionTraceback)
        self.infile.close()
        pass

    def add(self, c, v):
        raise ParseException(c.filename, c.lineno,
                             "Can't add elements to a multi");
        pass

    def toNum(self, s):
        # Eliminate leading zeros
        i = 0
        l = len(s)
        if (l == 0):
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number: " + s)
        while ((i < l) and (s[i] == '0')):
            i += 1
            pass
        if (i == l):
            return 0
        if ((i > 0) and (s[i] == 'x')):
            i -= 1
            pass
        try:
            v = int(s[i:], 0)
        except TypeError as e:
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number: " + s)
        except ValueError as e:
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number: " + s)
        return v

    def splitup_line(self, l):
        v = []
        instr = False
        inname = False
        inquote = False
        i = 0
        last = len(l)
        start = 0
        while (i < last):
            c = l[i]
            if (inquote):
                inquote = False
                pass
            elif (instr and (c == '"')):
                v.append(unquote(l[start:i]))
                instr = False
            elif (inname and c.isspace()):
                v.append(unquote(l[start:i]))
                inname = False
            elif (c == '"'):
                start = i + 1
                instr = True
            elif (not (inname or instr) and not c.isspace()):
                if (c == '\\'):
                    inquote = True
                    pass
                start = i
                inname = True
            elif (c == '\\'):
                inquote = True
                pass
            i += 1
            pass

        if (inquote):
            raise ParseException(self.filename, self.lineno,
                                 "End of line after '\\'");
        if (instr):
            raise ParseException(self.filename, self.lineno,
                                 "End of line in string");
        if (inname):
            v.append(l[start:i])
        return v

    def parseLine(self, s):
        if (self.curr == None):
            if (s[0] == "enum"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Enum has no name")
                self.curr = Enum(s[1])
            elif (s[0] == "slist"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Slist has no name")
                self.curr = SList(s[1])
            elif (s[0] == "list"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "List has no name")
                if (len(s) < 3):
                    raise ParseException(self.filename, self.lineno,
                                         "List has no length")
                i = s[2].find('(')
                if (i == -1):
                    base = 0
                    length = self.toNum(s[2])
                else:
                    ep = s[2].find(')')
                    if ((ep == -1) or (ep != (len(s[2]) - 1))):
                        raise ParseException(self.filename, self.lineno,
                                             "List base doesn't end with ')'")
                    length = self.toNum(s[2][0:i])
                    base = self.toNum(s[2][i+1:ep])
                    pass

                self.curr = List(s[1], length, s[3:], base)
            elif (s[0] == "tab"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Tab has no name")
                self.curr = Tab(s[1])
            elif (s[0] == "multi"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Multi has no name")
                RadioConfig(self.filename, self.filedata,
                            parent=self, name=s[1])
            else:
                raise ParseException(self.filename, self.lineno,
                                     "Invalid token: '" + s[0] + "'")
        else:
            self.curr.add(self, s)
            pass
        pass

    def addEnum(self, e):
        for i in self.types:
            if (i.name == e.name):
                raise ParseException(self.filename, self.lineno,
                                     "Duplicate type: " + e.name)
            pass
        self.types.append(e)
        self.curr = None
        pass

    def findType(self, s):
        for i in self.types:
            t = i.matchName(self, s)
            if (t):
                return t
            pass
        raise ParseException(self.filename, self.lineno, "Unknown type: " + s)

    def addList(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def addTab(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def addMulti(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def setup(self, pwid):
        self.tabs = tkinter.tix.NoteBook(pwid);
        self.tabs.pack(side=tkinter.tix.TOP, fill=tkinter.tix.BOTH, expand=1)
        for t in self.toplevel:
            t.tab = self.tabs.add(t.name.lower(), label=t.name)
            t.setup(t.tab)
            pass

    pass

class RadioSel:
    def __init__(self, parent, radio):
        self.parent = parent
        self.radio = radio
        return

    def selected(self):
        self.parent.newradio(self.radio)
        return
    pass

class MyTop(tkinter.tix.Tk):
    """We have our own top-level widget so we can catch destroy calls
    and do a dialog if the data has changed"""
    def destroy(self):
        self.destroyhandler()
        return

    def realDestroy(self):
        tkinter.tix.Tk.destroy(self)
        return

    pass

class GUI(tkinter.tix.Frame):
    def __init__(self, filename, master):
        master.destroyhandler = self.quitcmd

        tkinter.tix.Frame.__init__(self, master)
        self.top = master
        self.pack(fill=tkinter.tix.BOTH, expand=1);
        master.geometry('800x400')
        self.config = GenConfig()
        self.createWidgets();
        self.filedialog = tkinter.tix.FileSelectDialog(master,
                                               command=self.open_select)
        self.saveasdialog = tkinter.tix.FileSelectDialog(master,
                                                 command=self.saveas_select)
        if (filename):
            self.openfile(filename)
            pass
        else:
            master.wm_title("yaesu edit")
            self.fd = None
        pass

    def openfile(self, filename):
        try:
            self.fd = RadioFileData(filename)
        except IOError as e:
            d = tkinter.dialog.Dialog(self, title="Open File",
                              text=str(e),
                              bitmap="error",
                              default = 0,
                              strings=("Ok",))
            self.fd = None
            pass

        if (not self.fd):
            return

        self.fd.config = self.config

        try:
            self.radioname = find_radio(self.fd.data)
            if (not self.radioname):
                d = tkinter.dialog.Dialog(self, title="Error Finding Radio",
                                  text=("Unable to find a radio that matches"
                                        + " the file %s, it is likely not a"
                                        + " radio save file.") % filename,
                                  bitmap="error",
                                  default = 0,
                                  strings=("Ok",))
                return
            self.radio = RadioConfig(radiodir + "/" + self.radioname + ".rad",
                                     self.fd)
        except Exception as e:
            exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
            traceback.print_exception(exceptionType, exceptionValue,
                                      exceptionTraceback,
                                      file=sys.stdout)
            print(str(e))
            return
        self.master.wm_title(filename + " (" + self.radioname + ")")
        self.radio.setup(self)
        pass

    def quitcmd(self, event=None):
        if (not self.fd or not self.fd.changed):
            self.top.realDestroy()
            return
        d = tkinter.dialog.Dialog(self, title="Ok to quit?",
                          text=("Unchanged data has not been written, do you"
                                + " really want to quit?"),
                          bitmap="error",
                          default = 1,
                          strings=("Yes","No"))
        if (d.num == 0):
            self.top.realDestroy()
            pass
        pass

    def opencmd(self, event=None):
        self.filedialog.popup()
        pass

    def open_select(self, filename):
        if (not filename):
            return None
        if (not self.fd):
            g = self
            self.openfile(filename)
        else:
            g = GUI(filename, MyTop())
            pass
        return g

    def saveascmd(self, event=None):
        if (not self.fd):
            return
        self.saveasdialog.popup()
        pass

    def saveas_select(self, filename=None):
        if (not filename):
            return
        self.fd.write(filename)
        return

    def savecmd(self, event=None):
        if (self.fd.filename is None):
            return self.saveascmd()
        self.fd.write()
        return

    def newradio(self, r):
        filename = radiodir + "/" + r.name + ".empty"
        g = self.open_select(filename)
        if g:
            # Make sure to not save the file back to the empty file.
            g.fd.filename = None
            pass
        pass

    def rptShftCmd(self):
        self.config.doRptOffsets = not self.config.doRptOffsets
        return

    def createWidgets(self):
        self.buttons = tkinter.tix.Frame(self)
        self.buttons.pack(side=tkinter.tix.TOP, fill=tkinter.tix.X)

        self.filebutton = tkinter.tix.Menubutton(self.buttons, text="File",
                                         underline=0, takefocus=0)
        self.filemenu = tkinter.tix.Menu(self.filebutton, tearoff=0)
        self.filebutton["menu"] = self.filemenu
        m = tkinter.tix.Menu(self.filemenu)
        for r in radios:
            ns = RadioSel(self, r)
            m.add_command(label=r.name,
                          command = lambda ns=ns: ns.selected())
            pass
        self.filemenu.add_cascade(label="New", underline=1, menu=m)
        self.filemenu.add_command(label="Open", underline=1,
                                  accelerator="Ctrl+O",
                                  command = lambda self=self: self.opencmd() )
        self.filemenu.add_command(label="Save", underline=1,
                                  accelerator="Ctrl+S",
                                  command = lambda self=self: self.savecmd() )
        self.filemenu.add_command(label="Save As", underline=1,
                                  command = lambda self=self: self.saveascmd())
        self.filemenu.add_command(label="Exit", underline=1,
                                  accelerator="Ctrl+Q",
                                  command = lambda self=self: self.quitcmd() )
        self.top.bind_all("<Control-O>", self.opencmd)
        self.top.bind_all("<Control-o>", self.opencmd)
        self.top.bind_all("<Control-Q>", self.quitcmd)
        self.top.bind_all("<Control-q>", self.quitcmd)
        self.top.bind_all("<Control-S>", self.savecmd)
        self.top.bind_all("<Control-s>", self.savecmd)
        self.filebutton.pack(side=tkinter.tix.LEFT)

        self.editbutton = tkinter.tix.Menubutton(self.buttons, text="Edit",
                                         underline=0, takefocus=0)
        self.editmenu = tkinter.tix.Menu(self.editbutton, tearoff=0)
        self.editbutton["menu"] = self.editmenu
        self.editmenu.add_checkbutton(label="Auto Rpt Shift", underline=1,
                                      command = lambda
                                      self=self: self.rptShftCmd() )
        self.editbutton.pack(side=tkinter.tix.LEFT)

        if self.config.doRptOffsets:
            self.config.doRptOffsets = False
            self.editmenu.invoke(0)
            pass
        return

    pass

progname = sys.argv[0]

while len(sys.argv) > 1:
    if (sys.argv[1][0] != '-'):
        break
    if (sys.argv[1] == '--'):
        del sys.argv[0]
        break
    if (sys.argv[1] == '--configdir' or sys.argv[1] == '-F'):
        if (len(sys.argv[1]) < 2):
            print("No configuration directory given with " + sys.argv[1])
            sys.exit(1)
            pass
        del sys.argv[1]
        radiodir = sys.argv[1]
        del sys.argv[1]
    else:
        print("Unknown option: " + sys.argv[1])
        sys.exit(1)
        pass
    pass

read_radios()

if (len(sys.argv) > 1):
    for filename in sys.argv[1:]:
        gui = GUI(filename, MyTop());
        pass
    pass
else:
    gui = GUI(None, MyTop());
    pass

gui.mainloop();
sys.exit(0)
