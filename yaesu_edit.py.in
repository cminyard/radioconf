#!/usr/bin/env python
#
#    yaesu_edit - Edit yaesu clone files
#    Copyright (C) 2009  Corey Minyard
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor,
#      Boston, MA  02110-1301  USA

import sys
import traceback
import Tix
import Dialog

radiodir = "@YCONF@"

decimal_digits = "0123456789"

# These are internal Yaesu string values for some radios, and a clean set
# of characters to allow in general strings.
ys_chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ !\"\\$#%'()*+,-;/|:<=>?@[&]^_"

class ParseException(Exception):
    def __init__(self, filename, lineno, err):
        self.filename = filename
        self.lineno = lineno.get()
        self.err = err
        pass
    
    def __str__(self):
        return self.filename + "(" + str(self.lineno) + "): " + self.err
    
    pass

class DataException(Exception):
    def __init__(self, err):
        self.err = err
        pass

    def __str__(self):
        return self.err
    
    pass

class RadioInfo:
    def __init__(self, name):
        self.name = name;
        self.headercmp = []
        return

    pass

radios = []

def find_radio(data):
    for r in radios:
        if (len(data) < len(r.headercmp)):
            continue
        found = True
        i = 0
        for b in r.headercmp:
            if (b != data[i]):
                found = False
                break
            i += 1
            pass
        if (found):
            return r.name
        pass
    return None

# Throws IOError and ParseException
def read_radios():
    filename = radiodir + "/radios"
    f = open(filename, "r");
    try:
        lineno = 0
        in_radio = False
        l = ""
        while True:
            l += f.readline()
            if (not l):
                break;
            lineno += 1
            if l[len(l) - 1] == '\\':
               continue 
            if l[0] == '#':
                l = ""
                continue
            v = l.split();
            l = ""
            if (not v):
                continue
            if (v[0] == "radio"):
                if (in_radio):
                    raise ParseException(filename, lineno,
                                         "Got radio start inside a radio")
                if (len(v) < 2):
                    raise ParseException(filename, lineno,
                                         "No radio specified")
                curr_radio = RadioInfo(v[1])
                in_radio = True
                continue
            if (v[0] == "endradio"):
                if (not in_radio):
                    raise ParseException(filename, lineno,
                                         "Got radio end outside a radio")
                if (len(curr_radio.headercmp) == 0):
                    raise ParseException(filename, lineno,
                                         "No headercmp for radio")
                radios.append(curr_radio)
                in_radio = False
                continue
            if (v[0] == "headercmp"):
                if (not in_radio):
                    raise ParseException(filename, lineno,
                                         "Got headercmp outside a radio")
                try:
                    i = 0
                    found = True
                    for ns in v[1:]:
                        n = int(ns, 16)
                        if (n > 255):
                            raise TypeError("Number too large")
                        curr_radio.headercmp.append(n)
                        i += 1
                        pass
                    pass
                except TypeError, e:
                    raise ParseException(filename, lineno,
                                         "invalid hexadecimal 8-bit number")
                except ValueError, e:
                    raise ParseException(filename, lineno,
                                         "invalid hexadecimal 8-bit number")
                pass
            pass
        pass
    except:
        exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
        f.close()
        raise exceptionType, exceptionValue, exceptionTraceback
    return

class Address:
    def __init__(self, c, s):
        l = len(s)
        if (l == 0):
            raise ParseException(c.filename, c.lineno,
                                 "Empty location");
        if (s[0] != '('):
            raise ParseException(c.filename, c.lineno,
                                 "Address doesn't start with (");
        if (s[l-1] != ')'):
            raise ParseException(c.filename, c.lineno,
                                 "Address doesn't end with )");
        self.entries = []
        self.revbits = False # Bits are numbered from 0 by default
        i = 1
        l -= 1
        pos = 0
        start = 1
        v = [0, 0, 0, 0]
        self.entries.append(v)
        while (i < l):
            if (s[i] == ','):
                v[pos] = c.toNum(s[start:i])
                start = i + 1
                pos += 1
                if (pos > 3):
                    raise ParseException(c.filename, c.lineno,
                                         "Address has too many values"
                                         + " in a field");
                pass
            elif (s[i] == ':'):
                if (pos < 2 or pos > 3):
                    raise ParseException(c.filename, c.lineno,
                                         "Address has too few values"
                                         + " in a field");
                v[pos] = c.toNum(s[start:i])
                start = i + 1
                pos = 0
                v = [0, 0, 0, 0]
                self.entries.append(v)
                pass
            i += 1
            pass
        if (pos < 2 or pos > 3):
            raise ParseException(c.filename, c.lineno,
                                 "Address has too few values"
                                 + " in a field");
        if ((pos == 3) and (s[start] == 'r')):
            # Number bits starting with the high order.
            start += 1
            self.revbits = True
            pass
        v[pos] = c.toNum(s[start:i])
        return

    def numbits(self):
        numbits = 0
        for a in self.entries:
            numbits += a[2]
            pass
        return numbits
    
    pass


class RadioFileData:
    # Throws IOError
    def __init__(self, filename):
        self.filename = filename
        f = open(filename, "rb")
        strdata = f.read();
        f.close()
        self.data = []
        for c in strdata:
            self.data.append(ord(c))
        self.changed = False
        pass

    def write(self, filename=None):
        if (filename == None):
            filename = self.filename
        else:
            self.filename = filename
            pass
        outs = []
        for c in self.data:
            outs.append(chr(c))
            pass
        s = "".join(outs)
        try:
            f = open(filename, "wb")
            f.write(s)
        finally:
            f.close()
            pass
        self.changed = False
        pass

    # The get and set routine throw IndexError if out of range.
    
    def get_bits(self, addr, num):
        v = 0
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off / 8
            bit_off %= 8
            numbits = a[2]
            v <<= numbits

            if (addr.revbits):
                # FIXME - This doesn't work for multi-byte revbits
                x = self.data[byte_off] >> (8 - numbits - bit_off)
            else:
                x = self.data[byte_off] >> bit_off
                pass
            bitsleft = numbits - (8 - bit_off)
            while (bitsleft >= 8):
                byte_off += 1
                x <<= 8
                x |= self.data[byte_off]
                bitsleft -= 8
                pass
            if (bitsleft > 0):
                byte_off += 1
                x <<= bitsleft
                if (addr.revbits):
                    x1 = self.data[byte_off] >> (8 - bitsleft)
                    x1 &= ~(0xffffffff << bitsleft)
                    x |= x1
                else:
                    x |= self.data[byte_off] & ~(0xffffffff << bitsleft)
                    pass
                pass
            v |= x & ~(0xffffffff << numbits)
            pass
        return v

    def set_bits(self, vt, addr, num):
        self.changed = True
        bitsleft = 0
        for a in addr.entries:
            bitsleft += a[2]
            pass
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off / 8
            bit_off %= 8
            numbits = a[2]
            bitsleft -= numbits

            v = vt >> bitsleft
            v = v & ~(0xffffffff << numbits)
        
            x = self.data[byte_off]
            if ((bit_off + numbits) <= 8):
                # Special case, all in one byte
                if (addr.revbits):
                    mask = (0xff >> (8 - numbits)) << (8 - numbits - bit_off)
                else:
                    mask = (0xff >> (8 - numbits)) << bit_off
                    pass
                x &= ~mask
                if (addr.revbits):
                    x |= (v << (8 - numbits - bit_off)) & mask
                else:
                    x |= (v << bit_off) & mask
                    pass
                self.data[byte_off] = x
                continue
            # FIXME - no support for the 'r' flag in the following.
            mask = 0xff << bit_off
            x &= ~mask
            self.data[byte_off] = x | ((v >> (numbits - (8 -bit_off))) & mask)
            self.data[byte_off] &= 0xff
            byte_off += 1
            numbits -= 8 - bit_off
            while (numbits >= 8):
                self.data[byte_off] = (v >> (numbits - 8)) & 0xff
                self.data[byte_off] &= 0xff
                byte_off += 1
                numbits -= 8
                pass
            if (numbits > 0):
                mask = 0xff << numbits
                x = self.data[byte_off]
                x &= mask
                x |= v & ~mask;
                self.data[byte_off] = x & 0xff
                pass
            pass
        pass

    def get_bytes(self, addr, num):
        byte_pos = addr.entries[0][0] + (addr.entries[0][3] * num / 8)
        numbytes = addr.entries[0][2] / 8
        return self.data[byte_pos:byte_pos+numbytes]

    def set_byte(self, v, addr, num, offset):
        byte_pos = addr.entries[0][0] + (addr.entries[0][3] * num / 8)
        self.changed = True
        self.data[byte_pos + offset] = v
        pass

    def get_string(self, addr, num):
        if (len(addr) != 1):
            raise DataException("String formats only support one"
                                + " location field")
        if (addr[0][2] != 0):
            raise DataException("String formats must of a zero bit offset")
        if ((addr[0][3] % 8) != 0):
            raise DataException("String formats must have a byte-multiple"
                                + " offset")
        byte_off = addr[0][0] + (addr[0][3] * num / 8)
        numbytes = addr[0][2]

        s = []
        for i in (0, numbyte):
            s.append(chr(self.data[byte_off+i]))
            pass
        for i in range(0, len(s)):
            if (s[i] not in ys_chars):
                if (s[i].islower()):
                    s[i] = s[i].upper()
                    continue
                s[i] = ' '
                pass
            pass
        s = "".join(s)
        return s
    
    def set_string(self, v, addr, num):
        if (len(addr) != 1):
            raise DataException("String formats only support one"
                                + " location field")
        if (addr[0][2] != 0):
            raise DataException("String formats must of a zero bit offset")
        if ((offset % 8) != 0):
            raise DataException("String formats must have a byte-multiple"
                                + " offset")
        byte_off = addr[0][0] + (addr[0][3] * num / 8)
        numbytes = addr[0][2]

        self.changed = True
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                c = " "
            else:
                c = v[i]
                pass
            if c not in ys_chars:
                c = " "
                pass
            self.data[byte_off] = ord(c)
            byte_off += 1
            pass
        pass
    
    pass


class HandlerTie:
    def __init__(self, handler, tie):
        self.handler = handler
        self.tie = tie
        return
    pass

class Handler:
    """This is an internal type that eases handling events for a type.
    The type objects do not own the data about the particular object
    they are used to represent, since they are reused for many
    different objects.  Instead, when a widget is allocated to handle
    a particular type, one of these is allocated to hold that data and
    deliver it to the type object."""
    def __init__(self, handler, data, wtype):
        self.handler = handler
        self.data = data
        self.type = wtype
        self.widget = None # Will be filled in later by the type

        # The set of widgets/handlers we are tied to.  When the widget
        # associated with this handler changes, we call everything in
        # the tie list.  This is a list of HandlerTie object.
        self.tielist = []

        # These are ties to me that change the way I behave.  We keep these
        # as lists becaue there may be more than one tie to me, and only
        # one of them is required to be valid, so we may have to scan them.
        self.offtie = []
        self.basefreqtie = []
        self.offfreqtie = []
        
        self.enabletie = None
        self.enableoffsettie = None
        pass

    def addTie(self, h, tie):
        self.tielist.append(HandlerTie(h, tie))

        # Inform the widget we are tied to them, in case they care
        h.newTie(self, tie)
        return

    def newTie(self, fromh, tie):
        self.type.newTie(self, fromh, tie)
        if (fromh.widget):
            fromh.modified()
        return
    
    # Called when the user modifies a value.  Not required for setSelect
    # because that does a full redisplay.  Causes any tied values to be
    # redisplayed.
    def modified(self):
        for ht in self.tielist:
            ht.tie.redisplay(ht.handler)
            pass
        return

    def getValue(self, num):
        return self.type.getValue(self, num)
    
    def getSelect(self, num):
        return self.type.getSelect(self, num)
    
    def setSelect(self, v, num):
        return self.type.setSelect(v, self, num)
    
    def set(self):
        self.handler(self)
        pass

    def set_event(self, event):
        return self.handler(self, event)

    pass

def rewriteEntry(w, v):
    """Rewrite the value in an entry widget, setting the state to normal so
    it is writable, the setting the value, then setting the state back"""

    oldstate = w["state"]
    if (oldstate != "normal"):
        w["state"] = "normal"
        pass
    w.delete(0, 'end')
    w.insert(0, v)
    if (oldstate != "normal"):
        w["state"] = oldstate
        pass
    return

class YType:
    """This is the base class for all the different types that may be
    declared in a radio file."""
    def __init__(self, name):
        self.name = name
        self.displayheader = True
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        return None

    def getWidgetHandler(self, parent, t, num):
        h = Handler(None, None, self)
        h.widget = None
        return h

    def renumWidget(self, h, num):
        if h.enabletie:
            v = int(h.enabletie.getValue(num))
            if v:
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "disabled"
                pass
            pass
        elif h.enableoffsettie:
            v = h.enableoffsettie.getValue(num)
            if (v == "+" or v == "-"):
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "disabled"
                pass
            pass
        pass

    def redisplay(self, h):
        self.renumWidget(h, h.num)
        return
    
    def checkAddrOk(self, c, addr):
        return True

    def getSelect(self, h, num):
        return ""
    
    def getValue(self, h, num):
        # Most types are the same for select and value
        return self.getSelect(h, num)
    
    def setSelect(self, v, h, num):
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "enable"):
            myh.enabletie = fromh
        elif (tie.tietype == "enableoff"):
            myh.enableoffsettie = fromh
        elif (tie.tietype != "normal"):
            print ("Warning: Unknown type %s tie to %s"
                   % (tie.tietype, tie.value))
            pass
        if (myh.widget):
            self.redisplay(myh)
            pass
        return
    
    pass

class BISpecial(YType):
    def __init__(self, name="Special"):
        YType.__init__(self, name)
        self.displayheader = False
        pass

    def getWidgetHandler(self, parent, t, num):
        h = Handler(None, t, self)
        # This is not actually displayed.
        h.widget = None
        h.num = num
        return h

    def getSelect(self, h, num):
        t = h.data
        return str(t.data.get_bits(t.addr, num))
    
    def getValue(self, h, num):
        t = h.data
        return str(t.data.get_bits(t.addr, num))
    
    def setSelect(self, v, h, num):
        t = h.data
        t.data.set_bits(int(v), t.addr, num)
        return
    
    pass

class BISpecial857A(BISpecial):
    def __init__(self, name="Special857A"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "offset"):
            myh.offtie.append(fromh)
        elif (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        if (myh.widget):
            self.redisplay(myh)
            pass
        return

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        oldv = t.data.get_bits(t.addr, num)
        if (off and off != "split"):
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
            return

        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (not bfreq):
            # bfreq should be coming later, don't get it now.
            return

        bfreq = int(bfreq)
        if (bfreq < 4000000):
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
                pass
        elif (bfreq < 8000000):
            if (oldv != 1):
                t.data.set_bits(1, t.addr, num)
                pass
        elif (bfreq < 11000000):
            if (oldv != 2):
                t.data.set_bits(2, t.addr, num)
                pass
        elif (bfreq < 14000000):
            if (oldv != 3):
                t.data.set_bits(3, t.addr, num)
                pass
        elif (bfreq < 40000000):
            if (oldv != 4):
                t.data.set_bits(4, t.addr, num)
                pass
        else:
            if (oldv != 5):
                t.data.set_bits(5, t.addr, num)
                pass
            pass
        pass

    pass        

class BISpecial857B(BISpecial):
    def __init__(self, name="Special857B"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        return

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        oldv = t.data.get_bits(t.addr, num)
        if (not bfreq):
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
            return
        if (bfreq < 0x4000000):
            if (oldv != 1):
                t.data.set_bits(1, t.addr, num)
        else:
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
            pass
        pass

    pass        

class BISetToZero(BISpecial):
    def __init__(self, name="SetToZero"):
        BISpecial.__init__(self, name)
        return

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "normal"):
            myh.offtie.append(fromh)
            pass
        return

    def renumWidget(self, h, num):
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if off is None:
            off = True
        else:
            off = int(off)
            pass
        
        if (off):
            t = h.data
            oldv = t.data.get_bits(t.addr, num)
            if (oldv != 0):
                t.data.set_bits(0, t.addr, num)
                pass
            pass
        pass

    pass        

class BIInt(YType):
    def __init__(self, name="Int"):
        YType.__init__(self, name)
        return

    def setup(self, minval, maxval, offset, multi, units):
        self.minval = minval
        self.maxval = maxval
        self.unsigned = minval >= 0
        self.offset = offset
        self.multi = multi
        self.units = units
        self.unitslen = len(units)
        return
    
    def matchName(self, c, string):
        if not string.startswith("Int("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 "Int does not end with ')'")
        spec = string[4:len(string)-1].split(",")
        if (len(spec) != 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid Int specifier")
        minval = c.toNum(spec[0])
        maxval = c.toNum(spec[1])
        if (minval >= maxval):
            raise ParseException(c.filename, c.lineno,
                                 "min must be < max value")
        offset = c.toNum(spec[2])
        multi = c.toNum(spec[3])
        if (multi <= 0):
            raise ParseException(c.filename, c.lineno,
                                 "Multiplier must be > 0")
        units = spec[4]
        b = BIInt(name=string)
        b.setup(minval, maxval, offset, multi, units)
        return b

    def getWidgetHandler(self, parent, t, num):
        v = self.getInt(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        w = Tix.Entry(parent, readonlybackground="tan")
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, str(v)+self.units)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        rewriteEntry(h.widget, str(v)+self.units)
        pass

    def getInt(self, data, addr, num):
        v = data.get_bits(addr, num)
        if (not self.unsigned):
            n = addr.numbits()
            if ((1 << n) & v):
                # Negative value
                v |= (-1 << n) | v
                pass
            pass
        v += self.offset
        v *= self.multi
        return v

    def setInt(self, v, data, addr, num):
        v /= self.multi
        v -= self.offset
        if (v < 0):
            v &= (-1 << addr.numbits())
            pass
        data.set_bits(v, addr, num)
        return
        
    def getSelect(self, h, num):
        t = h.data
        return str(self.getInt(t.data, t.addr, num))

    def setSelect(self, v, g, num):
        t = h.data
        try:
            self.setInt(int(v), t.data, t.addr, num)
        except Exception, e:
            pass
        pass

    def isvalidnum(self, s):
        try:
            i = int(s)
            if ((i < self.minval) or (i > self.maxval)):
                return None
            pass
        except Exception, e:
            return None
        
        return True
    
    def set(self, h, event):
        c = event.keysym
        if ((c == "Left") or (c == "Right")
            or (c == "Up") or (c == "Down")):
            # Let these through
            return
        if (c == "minus"):
            c = '-'
        elif ((c == "BackSpace") or (c == "Delete")):
            pass
        elif (len(c) > 1):
            return "break" # Ignore other editing keys
        if (c == '-' and self.unsigned):
            return "break"

        w = h.widget
        cursor = w.index("insert")
        end = w.index("end")
        if (cursor > (end - self.unitslen)):
            # Don't mess with the units.
            return "break"
        
        s = w.get()

        if (c == "BackSpace"):
            if (cursor == 0):
                return "break"
            s = s[0:cursor - 1] + s[cursor:]
            cursor -= 2
        elif (c == "Delete"):
            if (cursor >= len(s)):
                return "break"
            s = s[0:cursor] + s[cursor + 1:]
            cursor -= 1
        elif (c not in decimal_digits) and (c != '-'):
            return "break" # Ignore everything but numbers and '-'
        else:
            s = s[0:cursor] + c + s[cursor:]
            pass

        intstr = s[0:len(s)-self.unitslen]
        if (not self.isvalidnum(intstr)):
            return "break"

        t = h.data
        self.setInt(int(intstr), t.data, t.addr, h.num)

        h.widget.delete(0, 'end')
        w.insert(0, s)
        w.icursor(cursor + 1)
        return "break"

    pass

class BIString(YType):
    def __init__(self, name="String", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        elif string.startswith("String("):
            if not string.endswith(")"):
                raise ParseException(c.filename, c.lineno,
                                     "String does not end with ')'")
            spec = string[7:len(string)-1].split(",")
            if (len(spec) != 1):
                raise ParseException(c.filename, c.lineno,
                                     "Invalid String specifier")
            width = c.toNum(spec[0])
            return BIString(name=string, width=width)
        return None

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "String formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must be a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_string(self, data, addr, num):
        s = data.get_bytes(addr, num)
        for i in range(0, len(s)):
            if (chr(s[i]) not in ys_chars):
                s[i] = ' '
            else:
                s[i] = chr(s[i])
                pass
            pass
        s = "".join(s)
        return s

    def set_string(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                p = " "
            else:
                p = v[i].upper()
                pass
            data.set_byte(ord(p), addr, num, i)
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_string(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        h.v = v
        h.num = num
        w = Tix.Entry(parent, readonlybackground="tan")
        w["width"] = self.width
        h.widget = w
        w.bind("<KeyRelease>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        rewriteEntry(h.widget, self.get_string(t.data, t.addr, num));
        pass
        
    def getSelect(self, h, num):
        t = h.data
        return self.get_string(t.data, t.addr, num)

    def setSelect(self, v, h, num):
        t = h.data
        self.set_string(v, t.data, t.addr, num, None)
        pass

    def set(self, h, event):
        w = h.widget
        t = h.data
        v = w.get()
        if (v == h.v):
            return
        cursor = w.index("insert")
        self.set_string(v, t.data, t.addr, h.num, h)
        v = self.get_string(t.data, t.addr, h.num)
        w.delete(0, 'end')
        w.insert(0, v)
        w.icursor(cursor)
        h.v = v
        pass
    pass


class BIFixed(YType):
    def __init__(self, name="Fixed", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def setup(self, pre, suf, inc, units, snddec):
        # Number of digits to the left of the decimal
        self.pre = pre
        # Number of digits to the right of the decimal
        self.suf = suf
        # Each integer increment adds this much
        self.inc = inc
        # Units (like kHz, MHz, etc)
        self.units = units
        # Second decimal place location, -1 for none
        self.snddec = snddec

        self.numdec = 1

        # Total string length is prefix + suffix + the period
        self.len = pre + suf + 1
        if (self.snddec >= 0):
            self.snddec += 1 # Account for the first '.'
            self.len += 1
            self.numdec += 1
        pass

    def matchName(self, c, string):
        if not string.startswith("Fixed("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 "Fixed does not end with ')'")
        spec = string[6:len(string)-1].split(",")
        if (len(spec) < 4) or (len(spec) > 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid Fixed specifier")
        pre = c.toNum(spec[0])
        suf = c.toNum(spec[1])
        inc = c.toNum(spec[2])
        units = spec[3]
        snddec = -1
        width = self.width
        if (len(spec) >= 5):
            opts = spec[4].split(":")
            for opt in opts:
                o = opt.split("=", 1)
                if (o[0] == "w"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "w option requires value")
                    width = c.toNum(o[1])
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "Invalid Fixed option: " + o[0])
            pass
        b = BIFixed(name=string, width=width)
        b.setup(pre, suf, inc, units, snddec)
        return b

    def getWidgetHandler(self, parent, t, num):
        v = t.data.get_bits(t.addr, num)
        h = Handler(self.set, t, self)
        w = Tix.Entry(parent, readonlybackground="tan")
        w["width"] = self.width
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, self.conv_to_str(v))
        return h

    def getBits(self, h, num):
        t = h.data
        return t.data.get_bits(t.addr, num)
    
    def setBits(self, v, h, num):
        t = h.data
        t.data.set_bits(v, t.addr, num)
        return
    
    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        v = self.getBits(h, num)
        rewriteEntry(h.widget, self.conv_to_str(v))
        pass
        
    def getSelect(self, h, num):
        return self.conv_to_str(self.getBits(h, num))

    def getValue(self, h, num):
        t = h.data
        return str(t.data.get_bits(t.addr, num))

    def setSelect(self, v, h, num):
        self.setBits(self.conv_from_str(v), h, num)
        pass

    def set(self, h, event):
        if ((event.keysym == "Left") or (event.keysym == "Right")
            or (event.keysym == "Up") or (event.keysym == "Down")):
            # Let these through
            return
        if (len(event.keysym) > 1):
            return "break" # Ignore other editing keys

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= self.len):
            return "break" # Past the end of the entry
        if (cursor == self.pre) or (cursor == self.snddec):
            w.icursor(cursor + 1) # Skip over the '.'
            return "break"

        c = event.keysym
        if (c not in decimal_digits):
            return "break" # Ignore everything but numbers

        t = h.data
        s = w.get()
        if (s[cursor] != c):
            s = s[0:cursor-1] + c + s[cursor:]
            w.delete(cursor)
            w.insert(cursor, c)
            v = self.conv_from_str(w.get())
            self.setBits(v, h, h.num)
            h.modified()
            s = self.conv_to_str(v)
            h.widget.delete(0, 'end')
            w.insert(0, s)
            pass
        if (cursor == self.pre - 1) or (cursor == self.snddec - 1):
            w.icursor(cursor + 2) # Skip over the '.'
        else:
            w.icursor(cursor + 1)
        return "break"

    def conv_from_str(self, s):
        v = 0
        l = 0
        decloc = -1
        postdec = 0
        units = None
        for c in s:
            if (c == '.'):
                if (decloc == -1):
                    decloc = l
                    pass
                continue
            d = decimal_digits.find(c)
            if (d == -1):
                # Must be in the units
                units = s[l:]
                if (decloc == -1):
                    decloc = l
                    pass
                break
            if (decloc != -1):
                postdec += 1
                pass
            v *= 10
            v += d
            l += 1
            pass
        if (decloc == -1):
            decloc = l
            pass
        if (units and units != self.units):
            # Need to do a units conversion.
            if (self.units == "MHz"):
                if (units == "kHz"):
                    decloc -= 3
                    postdec += 3
                elif (units == "Hz"):
                    decloc -= 6
                    postdec += 6
                    pass
                pass
            elif (self.units == "kHz"):
                if (units == "MHz"):
                    decloc += 3
                    postdec -= 6
                elif (units == "Hz"):
                    decloc -= 3
                    postdec += 3
                    pass
                pass
            pass
        if (postdec > self.suf):
            v /= 10 * (postdec - self.suf)
        elif (postdec < self.suf):
            v *= 10 * (self.suf - postdec)
            pass
        
        # Make sure to round as necessary
        return (v + (self.inc / 2)) / self.inc

    def conv_to_str(self, v):
        s = str(v * self.inc)
        while (len(s) < (self.len - self.numdec)):
            s = "0" + s
            pass
        s = s[0:self.len - self.numdec]
        s = s[0:self.pre] + "." + s[self.pre:] + self.units
        if (self.snddec != -1):
            s = s[0:self.snddec] + "." + s[self.snddec:]
            pass
        return s
    pass

class BIFixedFreq(BIFixed):
    def getWidgetHandler(self, parent, t, num):
        h = BIFixed.getWidgetHandler(self, parent, t, num)
        return h
    
    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "offset"):
            myh.offtie.append(fromh)
        elif (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
        elif (tie.tietype == "freqoff"):
            myh.offfreqtie.append(fromh)
        else:
            YType.newTie(self, myh, fromh, tie)
            pass
        if (myh.widget):
            self.redisplay(myh)
            pass
        return

    def getBits(self, h, num):
        t = h.data
        freq = t.data.get_bits(t.addr, num)

        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (not off or off == "split"):
            return freq
        
        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (bfreq):
            bfreq = int(bfreq)
            pass
            
        if (off == "smplx"):
            if bfreq:
                return bfreq
            return freq

        if not bfreq:
            return freq

        if (off == "+"):
            return bfreq + freq
        elif (off == "-"):
            return bfreq - freq
        else:
            print("Warning: unknown offset: " + off)

        return freq
    
    def setBits(self, v, h, num):
        t = h.data
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (not off or off == "split"):
            t.data.set_bits(v, t.addr, num)
            return
        if (off == "smplx"):
            # Ignore in simplex mode
            return
        
        bfreq = None
        for m in h.basefreqtie:
            bfreq = m.getValue(num)
            if (bfreq):
                break
            pass
        if (bfreq):
            bfreq = int(bfreq)
            pass
            
        if not bfreq:
            pass
        elif (off == "+"):
            v = v - bfreq
        elif (off == "-"):
            v = bfreq - v
        else:
            print("Warning: unknown offset: " + off)
            pass
        t.data.set_bits(v, t.addr, num)
        return

    def renumWidget(self, h, num):
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "smplx"):
                h.widget["state"] = "readonly"
            else:
                h.widget["state"] = "normal"
                pass
            pass
        BIFixed.renumWidget(self, h, num)
        return
        
    def matchName(self, c, string):
        if not string.startswith("FixedFreq("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 "FixedFreq does not end with ')'")
        spec = string[10:len(string)-1].split(",")
        if (len(spec) < 4) or (len(spec) > 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid FixedFreq specifier")
        pre = c.toNum(spec[0])
        suf = c.toNum(spec[1])
        inc = c.toNum(spec[2])
        units = spec[3]
        snddec = -1
        width = self.width
        if (len(spec) >= 5):
            opts = spec[4].split(":")
            for opt in opts:
                o = opt.split("=", 1)
                if (o[0] == "sd"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "sd option requires value")
                    snddec = c.toNum(o[1])
                    if (snddec <= pre or snddec > (pre + suf)):
                        raise ParseException(c.filename, c.lineno,
                                             "sd option must be after pre"
                                             + " and before the end of the"
                                             + " number")
                    pass
                elif (o[0] == "w"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "w option requires value")
                    width = c.toNum(o[1])
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "Invalid Fixed option: " + o[0])
                pass
            pass
        b = BIFixedFreq(name=string, width=width)
        b.setup(pre, suf, inc, units, snddec)
        return b

    pass
    

class BICheckBox(YType):
    def __init__(self, name="CheckBox", reverse=False):
        YType.__init__(self, name)
        self.reverse = reverse
        pass

    def getWidgetHandler(self, parent, t, num):
        v = t.data.get_bits(t.addr, num)
        h = Handler(self.set, t, self)
        w = Tix.Checkbutton(parent, command=h.set)
        h.num = num
        h.widget = w
        h.v = v
        if self.reverse:
            v = ~v & 1
            pass
        if (v):
            w.select()
        else:
            w.deselect()
            pass
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        h.v = v
        if self.reverse:
            v = ~v & 1
            pass
        oldstate = h.widget["state"]
        if (oldstate != "normal"):
            h.widget["state"] = "normal"
            pass
        if (v):
            h.widget.select()
        else:
            h.widget.deselect()
            pass
        if (oldstate != "normal"):
            h.widget["state"] = oldstate
            pass
        pass
        
    def set(self, h):
        w = h.widget
        t = h.data
        if (h.v):
            h.v = 0
        else:
            h.v = 1
            pass
        v = h.v
        if self.reverse:
            v = ~v & 1
            pass
        t.data.set_bits(v, t.addr, h.num)
        h.modified()
        pass

    def getSelect(self, h, num):
        t = h.data
        v = t.data.get_bits(t.addr, num)
        if self.reverse:
            v = ~v & 1
            pass
        if (v):
            return '1'
        else:
            return '0'
    
    def setSelect(self, v, h, num):
        t = h.data
        if (v == "0"):
            v = 0
        elif (v == "1"):
            v = 1
        else:
            return
        if self.reverse:
            v = ~v & 1
            pass
        t.data.set_bits(v, t.addr, num)
        pass
    
    pass

class BIYaesuString(YType):
    def __init__(self, name="YaesuString", width=10):
        YType.__init__(self, name)
        self.width = width
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        elif string.startswith("YaesuString("):
            if not string.endswith(")"):
                raise ParseException(c.filename, c.lineno,
                                     "YaesuString does not end with ')'")
            spec = string[12:len(string)-1].split(",")
            if (len(spec) != 1):
                raise ParseException(c.filename, c.lineno,
                                     "Invalid YaesuString specifier")
            width = c.toNum(spec[0])
            return BIYaesuString(string, width=width)
        return None

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must be a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_yaesu_string(self, data, addr, num):
        s = data.get_bytes(addr, num)
        for i in range(0, len(s)):
            if (s[i] > 0x3f):
                s[i] = ' '
            else:
                s[i] = ys_chars[s[i]]
                pass
            pass
        s = "".join(s)
        return s

    def set_yaesu_string(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                p = 0x24
            else:
                p = ys_chars.find(v[i].upper())
                if (p < 0):
                    p = 0x24
                    pass
                pass
            data.set_byte(p, addr, num, i)
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_yaesu_string(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        h.v = v
        h.num = num
        w = Tix.Entry(parent, readonlybackground="tan")
        w["width"] = self.width
        h.widget = w
        w.bind("<KeyRelease>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        rewriteEntry(h.widget, self.get_yaesu_string(t.data, t.addr, num))
        pass
        
    def getSelect(self, h, num):
        t = h.data
        return self.get_yaesu_string(t.data, t.addr, num)

    def setSelect(self, v, h, num):
        t = h.data
        self.set_yaesu_string(v, t.data, t.addr, num, None)
        pass

    def set(self, h, event):
        w = h.widget
        t = h.data
        v = w.get()
        if (v == h.v):
            return
        cursor = w.index("insert")
        self.set_yaesu_string(v, t.data, t.addr, h.num, h)
        v = self.get_yaesu_string(t.data, t.addr, h.num)
        w.delete(0, 'end')
        w.insert(0, v)
        w.icursor(cursor)
        h.v = v
        pass
    pass

def convFromBCD(v):
    if (v >= 10) or (v < 0):
        return '0'
    return decimal_digits[v]

# Yaesu BCD format for frequency, see FT60-layout.txt
class BIBCDFreq(YType):
    def __init__(self):
        YType.__init__(self, "BCDFreq")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats must have a zero bit"
                                 + " offset")
        if (addr.entries[0][2] != 24):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats must be 24 bits long")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_bcd(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        add5 = s[i] >> 6
        v.append(convFromBCD(s[i] & 0xf))
        i += 1
        numbytes = 3
        while (i < numbytes):
            v.append(convFromBCD(s[i] >> 4))
            v.append(convFromBCD(s[i] & 0xf))
            i += 1
            pass
        if (add5 == 0x0):
            v.append('0.0')
        elif (add5 == 0x1):
            v.append('2.5')
        elif (add5 == 0x2):
            v.append('5.0')
        else:
            v.append('7.5')
            pass
        v.insert(3, '.')
        return "".join(v)
        pass

    # Yaesu BCD format for frequency, see FT60-layout.txt
    def set_bcd(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8

        vlen = len(v)
        add5 = v[vlen - 3]
        if (add5 < '2'):
            d = 0x0
        elif (add5 < '4'):
            d = 0x1 << 2
        elif (add5 < '7'):
            d = 0x2 << 2
        else:
            d = 0x3 << 2
            pass
        second = True
        i = 0
        for c in v[0:vlen - 1]:
            if c == '.':
                continue
            if (second):
                d <<= 4
                d |= decimal_digits.find(c)
                second = False
                data.set_byte(d, addr, num, i)
                i += 1
                pass
            else:
                d = decimal_digits.find(c)
                second = True
                pass
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_bcd(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        w = Tix.Entry(parent, readonlybackground="tan")
        w['width'] = 8
        h.widget = w
        h.num = num

        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def getStr(self, h, num):
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                pass
            else:
                freq = None
                for m in h.basefreqtie:
                    freq = m.getValue(num)
                    if (freq):
                        break
                    pass
                if (freq):
                    freq = freq[0:7] + freq[8]
                    freq = float(freq)
                    if (off != 'smplx'):
                        # It's a + or - offset, add/sub the offset frequency
                        o = None
                        for m in h.offfreqtie:
                            # Use getSelect, not getValue, because getSelect
                            # carries Mhz, kHz, etc.
                            o = m.getSelect(num)
                            if (o):
                                break
                            pass
                        if (o):
                            # Split out trailing MHz, Khz, Hz
                            i = 0
                            for c in o:
                                if (not c.isdigit() and c != '.'):
                                    break
                                i += 1
                                pass
                            sfx = o[i:]
                            o = o[0:i]
                            offfreq = float(o)
                            if (sfx == "kHz"):
                                offfreq /= 1000.0
                            elif (sfx == "Hz"):
                                offfreq /= 1000000.0
                                pass
                            pass
                        else:
                            offfreq = 0.0
                            pass
                        if (off == '+'):
                            freq += offfreq
                        elif (off == '-'):
                            freq -= offfreq
                        else:
                            print("Warning: unknown offset: " + off)
                            pass
                        pass
                    v = str(freq)
                    (pre, post) = v.split(".")
                    if (len(pre) > 4):
                        pre = 999
                        post = 999
                        pass
                    if (len(post) > 5):
                        post = post[0:4]
                        pass
                    while (len(pre) < 3):
                        pre = "0" + pre
                        pass
                    while (len(post) < 4):
                        post += "0"
                        pass
                    v = pre + "." + post[0:3] + "." + post[3]

                    return v;
                pass
            pass
        t = h.data
        return self.get_bcd(t.data, t.addr, num)

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                h.widget["state"] = "normal"
            else:
                h.widget["state"] = "readonly"
                pass
            pass
        h.num = num
        v = self.getStr(h, num)
        rewriteEntry(h.widget, v)
        pass

    def newTie(self, myh, fromh, tie):
        if (tie.tietype == "offset"):
            myh.offtie.append(fromh)
        elif (tie.tietype == "basefreq"):
            myh.basefreqtie.append(fromh)
            pass
        elif (tie.tietype == "freqoff"):
            myh.offfreqtie.append(fromh)
            pass
        else:
            YType.newTie(self, myh, fromh, tie)
            pass
        if myh.widget:
            self.redisplay(myh)
            pass
        return
    
    def getValue(self, h, num):
        t = h.data
        return self.get_bcd(t.data, t.addr, num)

    def getSelect(self, h, num):
        t = h.data
        # Note that we pad it out to Hz for copy/paste, for compatability
        return self.getStr(h, num) + ".000"

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert") or (event.keysym == "space")):
            return "break" # Don't allow deletions
        if (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= 7):
            return "break" # Past the end of the entry
        if (cursor == 3):
            w.icursor(cursor + 1) # Skip over the '.'
            return "break"

        c = event.keysym
        if (c not in decimal_digits):
            return "break" # Ignore everything but numbers

        if (cursor == 6):
            # Last digit can only be 0 or 5
            if (c < '2'):
                c = '0.0'
            elif (c < '4'):
                c = '2.5'
            elif (c < '7'):
                c = '5.0'
            else:
                c = '7.5'
                pass
            pass
                
        s = w.get()
        if (s[cursor] != c):
            for m in c:
                w.delete(cursor)
                pass
            w.insert(cursor, c)
            t = h.data
            self.set_bcd(w.get(), t.data, t.addr, h.num, h)
            pass
        if (cursor == 2):
            w.icursor(cursor + 2) # Skip over the '.'
        else:
            w.icursor(cursor + 1)
        return "break"

    def setSelect(self, v, h, num):
        firstc = False
        c2 = [ ]
        for c in v:
            if ((c != '.') and (c not in decimal_digits)):
                return
            if (c == '.'): # Cut off the last '.', if present
                if (firstc):
                    continue
                firstc = True;
                pass
            c2.append(c)
            pass

        v = "".join(c2)

        off = None
        for m in h.offtie:
            off = m.getValue(num)
            if (off):
                break
            pass
        if (off):
            if (off == "split"):
                pass
            else:
                bfreq = None
                for m in h.basefreqtie:
                    bfreq = m.getValue(num)
                    if (bfreq):
                        break
                    pass
                if (bfreq):
                    bfreq = bfreq[0:7] + bfreq[8]
                    bfreq = float(bfreq)
                    if (off != 'smplx'):
                        # It's a + or - offset, add/sub the offset frequency
                        o = None
                        for m in h.offfreqtie:
                            if (m.data.cutpaste):
                                o = m
                                pass
                            pass

                        if (o):
                            freq = float(v)
                            if (off == '+'):
                                offfreq = freq - bfreq
                            elif (off == '-'):
                                offfreq = bfreq - freq
                            else:
                                print("Warning: unknown offset: " + off)
                                return

                            o.setSelect(str(offfreq) + "MHz", num)
                            return
                        pass
                    pass
                pass
            pass

        t = h.data
        self.set_bcd(v, t.data, t.addr, num, None)
        pass
    pass

hex_digits = "0123456789ABCDEF "
def convFromHex(v):
    if (v == 0xff):
        return ' '
    if (v >= 16) or (v < 0):
        return '0'
    return hex_digits[v]

class BIHex(YType):
    def __init__(self):
        YType.__init__(self, "HexDigits")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigit formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_hex(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        numbytes = addr.entries[0][2] / 8
        while (i < numbytes):
            v.append(convFromHex(s[i]))
            i += 1
            pass
        return "".join(v)
        pass

    def set_hex(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8

        vlen = len(v)
        second = False
        i = 0
        for c in v:
            if (c == ' '):
                d = 0xff
            else:
                d = hex_digits.find(c)
            data.set_byte(d, addr, num, i)
            i += 1
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_hex(t.data, t.addr, num)
        h = Handler(self.set, t, self)
        h.numbytes = t.addr.entries[0][2] / 8
        w = Tix.Entry(parent, readonlybackground="tan")
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = self.get_hex(t.data, t.addr, num)
        rewriteEntry(h.widget, v)
        pass
        
    def getSelect(self, h, num):
        t = h.data
        return self.get_hex(t.data, t.addr, num)

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert")):
            return "break" # Don't allow deletions
        if (event.keysym == "space"):
            event.keysym = ' '
        elif (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= h.numbytes):
            return "break" # Past the end of the entry

        c = event.keysym.upper()
        if (c != ' ' and c not in hex_digits):
            return "break" # Ignore everything but numbers and space

        t = h.data
        s = w.get()
        if (s[cursor] != c):
            w.delete(cursor)
            w.insert(cursor, c)
            self.set_hex(w.get(), t.data, t.addr, h.num, h)
            pass
        w.icursor(cursor + 1)
        return "break"

    def setSelect(self, v, h, num):
        for c in v:
            if (c not in decimal_digits):
                return
            pass

        t = h.data
        self.set_hex(v, t.data, t.addr, num, None)
        pass
    pass

class MenuAndButton(Tix.Menubutton):
    def __init__(self, parent):
        Tix.Menubutton.__init__(self, parent)
        self.menu = Tix.Menu(self)
        self['menu'] = self.menu
        pass

    def add_command(self, name, handler):
        self.menu.add_command(label=name, command=handler)
        pass

    def set_label(self, label):
        self["text"] = label
    pass

class EnumEntry:
    def __init__(self, value, str):
        self.value = value
        self.str = str
        return
    pass

class Enum(YType):
    def __init__(self, name):
        YType.__init__(self, name)
        self.entries = []
        pass

    def add(self, c, v):
        if (v[0] == "endenum"):
            c.addEnum(self)
            return
        
        if (len(v) != 2):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for enum")

        n = c.toNum(v[0])
        for e in self.entries:
            if (e.value == n):
                raise ParseException(c.filename, c.lineno,
                                     "Enum value already used")
            if (e.str == v[1]):
                raise ParseException(c.filename, c.lineno,
                                     "Enum string already used")
            pass
        self.entries.append(EnumEntry(n, v[1]))
        pass

    def getWidgetHandler(self, parent, t, num):
        toph = Handler(None, t, self)
        toph.widget = MenuAndButton(parent)
        toph.num = num
        v = t.data.get_bits(t.addr, num)
        toph.widget.set_label("---")
        for e in self.entries:
            h = Handler(self.set, e, self)
            h.toph = toph
            toph.widget.add_command(e.str, h.set)
            if (v == e.value):
                toph.widget.set_label(e.str)
                pass
            pass
        return toph

    def set(self, h):
        e = h.data
        h.toph.widget.set_label(e.str)
        t = h.toph.data
        t.data.set_bits(e.value, t.addr, h.toph.num)
        h.toph.modified()
        pass

    def renumWidget(self, toph, num):
        YType.renumWidget(self, toph, num)
        toph.num = num
        t = toph.data
        v = t.data.get_bits(t.addr, num)
        found = False
        oldstate = toph.widget["state"]
        if (oldstate != "normal"):
            toph.widget["state"] = "normal"
            pass
        for e in self.entries:
            if (v == e.value):
                found = True
                toph.widget.set_label(e.str)
                break
            pass
        if (not found):
            toph.widget.set_label("---")
            pass
        if (oldstate != "normal"):
            toph.widget["state"] = oldstate
            pass
        pass

    def getSelect(self, h, num):
        t = h.data
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            if (v == e.value):
                return e.str.replace(" ", "")
            pass
        pass

    def setSelect(self, v, h, num):
        t = h.data
        for e in self.entries:
            if (v == e.str.replace(" ", "")):
                t.data.set_bits(e.value, t.addr, num)
                return
            pass
        pass
    
    pass

class SListEntry:
    def __init__(self, value, str, pos):
        self.value = value
        self.str = str
        self.pos = pos
        return
    pass

class SList(YType):
    def __init__(self, name):
        YType.__init__(self, name)
        self.entries = []
        pass

    def add(self, c, v):
        if (v[0] == "endslist"):
            c.addEnum(self)
            return
        
        if (len(v) != 2):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for enum")

        n = c.toNum(v[0])
        i = 0
        for e in self.entries:
            if (e.value == n):
                raise ParseException(c.filename, c.lineno,
                                     "List value already used")
            if (e.str == v[1]):
                raise ParseException(c.filename, c.lineno,
                                     "List string already used")
            i += 1
            pass
        self.entries.append(SListEntry(n, v[1], i))
        pass

    def getWidgetHandler(self, parent, t, num):
        h = Handler(self.set, t, self)
        h.widget = Tix.ScrolledListBox(parent, scrollbar='auto')
        h.widget.listbox['selectmode'] = "single"
        h.widget.listbox['activestyle'] = "dotbox"
        # If we export the selection, then the listbox loses
        # selection whenever something else gets it.
        h.widget.listbox['exportselection'] = "false"
        h.widget.listbox.bind("<<ListboxSelect>>", h.set_event)
        h.num = num
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            h.widget.listbox.insert(Tix.END, e.str)
            if (e.value == v):
                h.widget.listbox.selection_set(e.pos)
                h.widget.listbox.see(e.pos)
                pass
            pass
        return h

    def set(self, h, event):
        t = h.data
        pos = h.widget.listbox.curselection()
        if (len(pos) < 1):
            return
        pos = int(pos[0])
        e = self.entries[pos]
        t.data.set_bits(e.value, t.addr, h.num)
        pass

    def renumWidget(self, h, num):
        YType.renumWidget(self, h, num)
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        found = False
        oldstate = h.widget["state"]
        if (oldstate != "normal"):
            h.widget["state"] = "normal"
            pass
        for e in self.entries:
            if (v == e.value):
                h.widget.listbox.selection_set(e.pos)
                break
            pass
        if (oldstate != "normal"):
            h.widget["state"] = oldstate
            pass
        pass

    def getSelect(self, h, num):
        t = h.data
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            if (v == e.value):
                return e.str.replace(" ", "")
            pass
        pass

    def setSelect(self, v, h, num):
        t = h.data
        for e in self.entries:
            if (v == e.str.replace(" ", "")):
                t.data.set_bits(e.value, t.addr, num)
                return
            pass
        pass
    
    pass

class Tie:
    def __init__(self, value, tietype):
        self.tietype = tietype
        self.value = value
        self.widget = None
        return

    def setWidget(self, w):
        self.widget = w
        return

    def redisplay(self, h):
        self.widget.redisplay(h)
        return
    
    pass

class TabEntry:
    def __init__(self, name, pos, addr, type, data, tielist_str, cutpaste,
                 specials):
        self.name = name
        self.pos = pos
        nn = self.name.replace("\n", "")
        nn = nn.replace(" ", "")
        nn = nn.replace("\t", "")
        self.nsname = nn
        self.addr = addr
        self.type = type
        self.data = data
        self.specials = specials

        # The list of Tie items that we are tied to.
        self.tielist = tielist_str

        self.cutpaste = cutpaste

        self.displayheader = True
        pass

    def getWidgetHandler(self, parent, num):
        return self.type.getWidgetHandler(parent, self, num)

    def renumWidget(self, h, num):
        self.type.renumWidget(h, num)
        pass

    def redisplay(self, h):
        self.type.redisplay(h)
        return

    def getSelect(self, h, num):
        v = self.type.getSelect(h, num)
        if (v is None):
            v = ""
        return (self.nsname + "=" + v)

    def setSelect(self, h, num, vhash):
        if (self.nsname in vhash):
            v = vhash[self.nsname]
            del vhash[self.nsname]
            self.type.setSelect(v, h, num)
            pass
        elif "tone" in self.specials:
            tt = self.specials["tone"]
            if tt == "both":
                v = None
                if "TxToneMode" in vhash:
                    found = True
                    r = vhash["TxToneMode"]
                    del vhash["TxToneMode"]
                    if (r == "None"):
                        v = "None"
                    elif (r == "Tone"):
                        v = "Tone"
                    elif (r == "DCS"):
                        v = "DCode"
                        pass
                    pass
                if "RxToneMode" in vhash:
                    found = True
                    r = vhash["RxToneMode"]
                    del vhash["RxToneMode"]
                    if v is None:
                        v = "None"
                        pass
                    if (r == "Tone"):
                        if (v == "Tone"):
                            v = "T-SQL"
                        elif (v == "DCode"):
                            v = "TDCS"
                            pass
                        pass
                    elif (r == "DCS"):
                        if (v == "Tone"):
                            v = "DTone"
                        elif (v == "DCode"):
                            v = "DCS"
                            pass
                        pass
                        
                    pass
                if v:
                    self.type.setSelect(v, h, num)
                    pass
                pass
            elif tt == "rx":
                if "ToneMode" in vhash:
                    v = vhash["ToneMode"]
                    # Don't delete, tx tone might need it
                    if ((v == "T-SQL") or (v == "DTone")):
                        v = "Tone"
                    elif ((v == "DCS") or (v == "TDCS")):
                        v = "DCS"
                    else:
                        v = "None"
                        pass
                    self.type.setSelect(v, h, num)
                    pass
                pass
            elif tt == "tx":
                if "ToneMode" in vhash:
                    v = vhash["ToneMode"]
                    # Don't delete, rx tone might need it
                    if ((v == "T-SQL") or (v == "Tone") or (v == "TDCS")):
                        v = "Tone"
                    elif ((v == "DCS") or (v == "DCode") or (v == "DTone")):
                        v = "DCS"
                    else:
                        v = "None"
                        pass
                    self.type.setSelect(v, h, num)
                    pass
                pass
            pass
        return
    
    pass

class TabBase:
    def __init__(self, name):
        self.name = name

        # A list of TabEntry objects
        self.entries = []
        return

    def addItem(self, c, name, addr, type, opts):
        type.checkAddrOk(c, addr)

        ties = []
        cutpaste = True
        specials = { }
        for i in opts:
            s = i.split('=', 1)
            if len(s) != 2:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option, no '=': " + i)
            if (s[0] == "tie"):
                ties.append(Tie(s[1], "normal"))
            elif s[0].startswith("tie("):
                if not s[0].endswith(")"):
                    raise ParseException(c.filename, c.lineno,
                                         "tie type does not end with ')'")
                tietype = s[0][4:len(s[0])-1]
                ties.append(Tie(s[1], tietype))
            elif (s[0] == "cutpaste"):
                if (s[1].lower() == "true"):
                    cutpaste = True
                elif (s[1].lower() == "false"):
                    cutpaste = False
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "cutpaste takes true or false")
            elif (s[0] == "tone"):
                if (s[1] == "rx"):
                    specials["tone"] = "rx"
                elif (s[1] == "tx"):
                    specials["tone"] = "tx"
                elif (s[1] == "both"):
                    specials["tone"] = "both"
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "tone takes rx, tx, or both")
                pass
            else:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option: " + i);
            pass
            
        self.entries.append(TabEntry(name, len(self.entries), addr,
                                     type, c.filedata, ties, cutpaste,
                                     specials))
        return
    
    def finalize(self, c):
        for i in self.entries:
            for t in i.tielist:
                found = False
                for j in self.entries:
                    if (j.name == t.value):
                        t.setWidget(j)
                        found = True
                        break
                    pass
                if (not found):
                    raise ParseException(c.filename, c.lineno,
                                         ("tie entry for '" + t.value
                                          +"' not found"))
                pass
            pass
        return
    
    pass

class List(TabBase):
    """This is a list widget rework to make an HList that only has the
    items being displayed as list entries.  If you add the entire lists and
    scroll it and there are a thousand entries, a standard scrolled hlist
    is too slow because of the tens of thousands of widgets created.  So
    this class only creates widgets for the dislayed amount, then it
    redoes what is in the widgets based upon the scroll position."""
    def __init__(self, name, length, labels):
        TabBase.__init__(self, name)

        # Total length of elements in the list
        self.length = length

        # If supplied, these will be applied to as many list entries
        # as possible
        self.labels = labels
        
        # Number of lines currently displayed
        self.numdisplines = 0

        # Number of the first displayed line
        self.firstdispline = 0

        # A list of handlers for each displayed row
        self.handlerlists = []
        pass

    def add(self, c, v):
        if (v[0] == "endlist"):
            self.finalize(c)
            c.addList(self)
            return
        if (len(v) < 3):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for list entry")
        self.addItem(c, v[0], Address(c, v[1]), c.findType(v[2]), v[3:])
        pass

    def bindWidget(self, widget):
        widget.bind("<MouseWheel>", self.Wheel)
        widget.bind("<Down>", self.lineDown)
        widget.bind("<Up>", self.lineUp)
        widget.bind("<Next>", self.pageDown)
        widget.bind("<Prior>", self.pageUp)
        if (self.winsys == "x11"):
            widget.bind("<Button-4>", self.ButtonUpWheel)
            widget.bind("<Button-5>", self.ButtonDownWheel)
            pass
        pass
        
    def setup(self, top):
        try:
            self.winsys = top.tk.eval("return [ tk windowingsystem ]")
            pass
        except:
            # Assume x11
            self.winsys = "x11"
            pass

        self.xscroll = Tix.Scrollbar(top, orient=Tix.HORIZONTAL)
        self.yscroll = Tix.Scrollbar(top, orient=Tix.VERTICAL)
        self.list = Tix.HList(top, header=1, columns=len(self.entries) + 1,
                              itemtype="text", selectforeground="black",
                              selectbackground="beige",
                              yscrollcommand=self.y_scrolled,
                              xscrollcommand=self.xscroll.set)
        self.xscroll['command'] = self.list.xview
        self.yscroll['command'] = self.y_move
        self.xscroll.pack(side=Tix.BOTTOM, fill=Tix.X)
        self.yscroll.pack(side=Tix.RIGHT, fill=Tix.Y)

        self.list.selection_handle(self.selection_request)

        self.first_select = -1
        self.last_select = -1
        self.last_selection = ""
        self.last_selection_len = 0
        self.list.bind("<Button-1>", self.Button1)
        self.list.bind("<Shift-Button-1>", self.SButton1)
        self.list.bind("<Control-Button-1>", self.CButton1)
        self.list.bind("<Button-2>", self.Button2)
        self.list.bind("<Button-3>", self.Button3)

        self.list.bind("<Map>", self.mapped)

        self.bindWidget(self.list)
        self.bindWidget(self.xscroll)
        self.bindWidget(self.yscroll)
        
        i = 1
        for e in self.entries:
            e.column = i
            if (e.type.displayheader):
                self.list.header_create(i, text=e.name)
                self.list.column_width(i, "")
                pass
            i += 1
            pass

        self.list.pack(side=Tix.LEFT, fill=Tix.BOTH, expand=1)
        pass

    def mapped(self, event=None):
        self.list.focus_set()
        return
        
    def selection_request(self, offset, length):
        if (self.first_select < 0):
            return ""
        offset = int(offset)
        length = int(length)
        if (offset == 0):
            s = ""
            # Set up handlers, enough so the ties work for cutting/pasting
            handlers = []
            for e in self.entries:
                handlers.append(Handler(None, e, e.type))
                pass
            for e in self.entries:
                for t in e.tielist:
                    handlers[e.pos].addTie(handlers[t.widget.pos], t)
                    pass
                pass
            for i in range(self.first_select, self.last_select + 1):
                if (s):
                    s += "\n"
                    pass
                first = True
                for e in self.entries:
                    if (not e.cutpaste):
                        continue
                    if (not first):
                        s += " "
                    else:
                        first = False
                        pass
                    s += e.getSelect(handlers[e.pos], i)
                    pass
                pass
            self.last_selection = s
            self.last_selection_len = len(s)
            pass
        if (offset > self.last_selection_len):
            return ""
        elif ((offset + length) <= self.last_selection_len) :
            return self.last_selection[offset:offset + length]
        else:
            s = self.last_selection[offset:]
            self.last_selection = ""
            self.last_selection_len = 0
            return s
        return ""

    def redoSelection(self):
        if ((self.last_select < self.firstdispline)
            or (self.first_select >= self.firstdispline + self.numdisplines)):
            # Nothing to see
            self.list.selection_clear()
            return
        
        if (self.first_select <= self.firstdispline):
            pos1 = 0
        else:
            pos1 = self.first_select - self.firstdispline
            pass
        
        end = self.firstdispline + self.numdisplines - 1
        if (self.last_select >= end):
            pos2 = self.numdisplines - 1
        else:
            pos2 = self.last_select - self.firstdispline
            pass

        self.list.selection_clear()
        self.list.selection_set(pos1, pos2)
        self.list.selection_own()

        # For some reason, for me, the first one doesn't Actually cause
        # the display to change, doing it twice seems to fix the problem.
        self.list.selection_clear()
        self.list.selection_set(pos1, pos2)
        self.list.selection_own()
        pass
    
    def Button1(self, event):
        self.list.focus_set()
        line = int(self.list.nearest(event.y))
        self.first_select = self.firstdispline + line
        self.last_select = self.firstdispline + line
        self.redoSelection()
        return "break"
    
    def SButton1(self, event):
        if (self.first_select < 0):
            return self.Button1(event)
        line = int(self.list.nearest(event.y))
        pos = line + self.firstdispline
        if (pos <= self.first_select):
            self.first_select = pos
        else:
            self.last_select = pos
            pass
        self.redoSelection()
        return "break"
    
    def CButton1(self, event):
        return "break"
    
    def Button2(self, event):
        linenum = int(self.list.nearest(event.y)) + self.firstdispline
        s = self.list.selection_get()
        lines = s.split("\n")
        for l in lines:
            if (linenum >= self.length):
                return
            vhash = {}
            for vp in l.split():
                v = vp.split("=")
                if (len(v) != 2):
                    continue
                vhash[v[0]] = v[1]
                pass
            # Set up handlers, enough so the ties work for cutting/pasting
            handlers = []
            for e in self.entries:
                handlers.append(Handler(None, e, e.type))
                pass
            for e in self.entries:
                for t in e.tielist:
                    handlers[e.pos].addTie(handlers[t.widget.pos], t)
                    pass
                pass
            for e in self.entries:
                if (e.cutpaste):
                    e.setSelect(handlers[e.pos], linenum, vhash)
                    pass
                pass
            linenum += 1
            pass
        self.redisplay()
        return "break"
    
    def Button3(self, event):
        self.first_select = -1
        self.last_select = -1
        self.redoSelection()
        return "break"
    
    def Wheel(self, event):
        self.y_move("scroll", -(event.delta / 20), "units")
        return
    
    def ButtonUpWheel(self, event):
        event.delta = 120
        self.Wheel(event);
        return
    
    def ButtonDownWheel(self, event):
        event.delta = -120
        self.Wheel(event);
        return
    
    def y_scrolled(self, a, b):
        b = float(b)
        if (self.numdisplines < self.length) and (b >= 1.0):
            self.add_one_line()
        elif ((self.numdisplines > 0)
              and (b < (1.0 - (1.0 / float(self.numdisplines))))):
            self.del_one_line()
        else:
            pct = float(self.numdisplines) / float(self.length)
            first = float(self.firstdispline) / float(self.length)
            self.yscroll.set(first, first + pct)
            pass
        self.redoSelection()
        pass

    def pageDown(self, event=None):
        self.y_move("scroll", 1, "pages")
        return "break"
    
    def pageUp(self, event=None):
        self.y_move("scroll", -1, "pages")
        return "break"
    
    def lineDown(self, event=None):
        self.y_move("scroll", 1, "units")
        return "break"
    
    def lineUp(self, event=None):
        self.y_move("scroll", -1, "units")
        return "break"
    
    def y_move(self, a, b=None, c=None):
        if (a == "scroll"):
            if (c == "units"):
                if (int(b) < 0):
                    if (self.firstdispline > 0):
                        self.firstdispline -= 1
                        self.redisplay()
                        pass
                    pass
                else:
                    if ((self.firstdispline + self.numdisplines)
                        < self.length):
                        self.firstdispline += 1
                        self.redisplay()
                        pass
                    pass
                pass
            elif (c == "pages"):
                if (int(b) < 0):
                    if (self.firstdispline > (self.numdisplines - 1)):
                        self.firstdispline -= self.numdisplines - 1
                        self.redisplay()
                    elif (self.firstdispline > 0):
                        self.firstdispline = 0
                        self.redisplay()
                        pass
                    pass
                else:
                    if (self.firstdispline + (2 * self.numdisplines) - 1
                        <= self.length):
                        self.firstdispline += self.numdisplines - 1
                        self.redisplay()
                    elif (self.firstdispline + self.numdisplines
                          <= self.length):
                        self.firstdispline = self.length - self.numdisplines
                        self.redisplay()
                        pass
                    pass
                pass
        elif (a == "moveto"):
            pct = float(b)
            fl = int(pct * float(self.length))
            if ((fl != self.firstdispline)
                and (fl >= 0)
                and ((fl + self.numdisplines) <= self.length)):
                self.firstdispline = fl
                self.redisplay()
                pass
            pass
        pass

    def redisplay(self):
        i = 0
        for wl in self.handlerlists:
            pos = i + self.firstdispline
            if (pos < len(self.labels)):
                text = self.labels[pos]
            else:
                text = str(pos + 1)
            pass
            self.list.item_configure(i, 0, text=text)
            for e in self.entries:
                e.renumWidget(wl[e.pos], i + self.firstdispline)
                pass
            i += 1
            pass
        pass
    
    def add_one_line(self):
        handlers = []
        pos = self.firstdispline + self.numdisplines
        if (pos >= self.length):
            return
        if (pos < len(self.labels)):
            text = self.labels[pos]
        else:
            text = str(pos + 1)
            pass
        self.list.add(self.numdisplines, text=text)
        for e in self.entries:
            h = e.getWidgetHandler(self.list, pos)
            h.ename = e.name
            if (h.widget):
                self.bindWidget(h.widget)
                self.list.item_create(self.numdisplines, e.column,
                                      itemtype=Tix.WINDOW,
                                      window=h.widget)
                pass
            handlers.append(h)
            pass
        for e in self.entries:
            for t in e.tielist:
                handlers[e.pos].addTie(handlers[t.widget.pos], t)
                pass
            pass
        self.handlerlists.append(handlers)
        self.numdisplines += 1
        pass
        
    def del_one_line(self):
        if (self.numdisplines < 0):
            return
        self.numdisplines -= 1
        
        # FIXME - does this break all the pointer cycles?
        del self.handlerlists[self.numdisplines]
        self.list.delete_entry(self.numdisplines)
        pass
    
    pass

class Tab(TabBase):
    def __init__(self, name):
        TabBase.__init__(self, name)
        pass

    def add(self, c, v):
        if (v[0] == "endtab"):
            self.finalize(c)
            c.addTab(self)
            return
        if (len(v) < 3):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for tab entry");

        self.addItem(c, v[0], Address(c, v[1]), c.findType(v[2]), v[3:])
        return

    def bindWidget(self, widget):
        widget.bind("<MouseWheel>", self.Wheel)
        if (self.winsys == "x11"):
            widget.bind("<Button-4>", self.ButtonUpWheel)
            widget.bind("<Button-5>", self.ButtonDownWheel)
            pass
        pass
        
    def Wheel(self, event):
        self.list.hlist.yview("scroll", -(event.delta / 20), "units")
        return
    
    def ButtonUpWheel(self, event):
        event.delta = 120
        self.Wheel(event);
        return
    
    def ButtonDownWheel(self, event):
        event.delta = -120
        self.Wheel(event);
        return
    
    def setup(self, top):
        try:
            self.winsys = top.tk.eval("return [ tk windowingsystem ]")
            pass
        except:
            # Assume x11
            self.winsys = "x11"
            pass

        self.list = Tix.ScrolledHList(top, scrollbar="auto",
                                      options="hlist.header 1"
                                      + " hlist.columns 2"
                                      + " hlist.itemtype text"
                                      + " hlist.selectForeground black"
                                      + " hlist.selectBackground beige")
        self.list.hlist.header_create(0, text="Name")
        self.list.hlist.header_create(1, text="Value")
        self.list.hlist.column_width(0, "")
        self.list.hlist.column_width(1, "")
        self.bindWidget(self.list)
        self.bindWidget(self.list.hlist)
        self.bindWidget(self.list.hsb)
        self.bindWidget(self.list.vsb)

        i = 0
        handlers = []
        for e in self.entries:
            e.key = i
            self.list.hlist.add(i, text=e.name)
            h = e.getWidgetHandler(self.list.hlist, i)
            if (h.widget):
                self.list.hlist.item_create(i, 1, itemtype=Tix.WINDOW,
                                            window=h.widget)
                self.bindWidget(h.widget)
                pass
            handlers.append(h)
            i += 1
            pass
        for e in self.entries:
            for t in e.tielist:
                handlers[e.pos].addTie(handlers[t.widget.pos], t)
                pass
            pass

        self.list.pack(side=Tix.LEFT, fill=Tix.BOTH, expand=1)
        pass

    pass

quote_hash = {"n" : "\n",
              "t" : "\t",
              "r" : "\r" }

def unquote(s):
    inquote = False
    v = []
    for c in s:
        if (inquote):
            if (c in quote_hash):
                v.append(quote_hash[c])
            else:
                v.append(c);
                pass
            inquote = False
            pass
        elif (c == '\\'):
            inquote = True
            pass
        else:
            v.append(c)
            pass
        pass
    return "".join(v)

class LineNum:
    def __init__(self):
        self.val = 0
        return
    
    def get(self):
        return self.val

    def inc(self):
        self.val += 1
        return
    pass

class RadioConfig:
    def __init__(self, filename, filedata, parent=None, name=None):
        self.filename = filename
        self.filedata = filedata
        self.parent = parent
        self.name = name
        self.curr = None
        self.toplevel = []
        if (parent):
            self.types = self.parent.types
            self.infile = parent.infile
            self.lineno = parent.lineno
        else:
            self.types = [ BIBCDFreq(),
                           BICheckBox(),
                           BICheckBox(name="RCheckBox", reverse=True),
                           BIYaesuString(),
                           BIString(), YType("Empty"),
                           BIHex(), BIInt(), BIFixed(),
                           BIFixedFreq(), BISpecial(), BISpecial857A(),
                           BISpecial857B(), BISetToZero() ]
            self.infile = open(filename, "r")
            self.lineno = LineNum()
            pass
        try:
            while True:
                l = self.infile.readline();
                if (not l):
                    break
                self.lineno.inc()
                if l[0] == '#':
                    continue
                v = self.splitup_line(l);
                if (not v):
                    continue
                if (v[0] == "endmulti"):
                    if (not self.parent):
                        raise ParseException(self.filename, self.lineno,
                                             "got endmulti, but not in multi")
                    self.parent.addMulti(self)
                    return
                
                self.parseLine(v)
                pass
            pass
        except Exception, e:
            exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
            self.infile.close()
            raise exceptionType, exceptionValue, exceptionTraceback
        self.infile.close()
        pass

    def add(self, c, v):
        raise ParseException(c.filename, c.lineno,
                             "Can't add elements to a multi");
        pass

    def toNum(self, s):
        # Eliminate leading zeros
        i = 0
        l = len(s)
        if (l == 0):
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number: " + s)
        while ((i < l) and (s[i] == '0')):
            i += 1
            pass
        if (i == l):
            return 0
        if ((i > 0) and (s[i] == 'x')):
            i -= 1
            pass
        try:
            v = int(s[i:], 0)
        except TypeError, e:
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number: " + s)
        except ValueError, e:
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number: " + s)
        return v

    def splitup_line(self, l):
        v = []
        instr = False
        inname = False
        inquote = False
        i = 0
        last = len(l)
        start = 0
        while (i < last):
            c = l[i]
            if (inquote):
                inquote = False
                pass
            elif (instr and (c == '"')):
                v.append(unquote(l[start:i]))
                instr = False
            elif (inname and c.isspace()):
                v.append(unquote(l[start:i]))
                inname = False
            elif (c == '"'):
                start = i + 1
                instr = True
            elif (not (inname or instr) and not c.isspace()):
                if (c == '\\'):
                    inquote = True
                    pass
                start = i
                inname = True
            elif (c == '\\'):
                inquote = True
                pass
            i += 1
            pass

        if (inquote):
            raise ParseException(self.filename, self.lineno,
                                 "End of line after '\\'");
        if (instr):
            raise ParseException(self.filename, self.lineno,
                                 "End of line in string");
        if (inname):
            v.append(l[start:i])
        return v
    
    def parseLine(self, s):
        if (self.curr == None):
            if (s[0] == "enum"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Enum has no name")
                self.curr = Enum(s[1])
            elif (s[0] == "slist"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Slist has no name")
                self.curr = SList(s[1])
            elif (s[0] == "list"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "List has no name")
                if (len(s) < 3):
                    raise ParseException(self.filename, self.lineno,
                                         "List has no length")
                length = self.toNum(s[2])
                self.curr = List(s[1], length, s[3:])
            elif (s[0] == "tab"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Tab has no name")
                self.curr = Tab(s[1])
            elif (s[0] == "multi"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Multi has no name")
                RadioConfig(self.filename, self.filedata,
                            parent=self, name=s[1])
            else:
                raise ParseException(self.filename, self.lineno,
                                     "Invalid token: '" + s[0] + "'")
        else:
            self.curr.add(self, s)
            pass
        pass

    def addEnum(self, e):
        for i in self.types:
            if (i.name == e.name):
                raise ParseException(self.filename, self.lineno,
                                     "Duplicate type: " + e.name)
            pass
        self.types.append(e)
        self.curr = None
        pass

    def findType(self, s):
        for i in self.types:
            t = i.matchName(self, s)
            if (t):
                return t
            pass
        raise ParseException(self.filename, self.lineno, "Unknown type: " + s)
    
    def addList(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def addTab(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def addMulti(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def setup(self, pwid):
        self.tabs = Tix.NoteBook(pwid);
        self.tabs.pack(side=Tix.TOP, fill=Tix.BOTH, expand=1)
        for t in self.toplevel:
            t.tab = self.tabs.add(t.name.lower(), label=t.name)
            t.setup(t.tab)
            pass

    pass

class RadioSel:
    def __init__(self, parent, radio):
        self.parent = parent
        self.radio = radio
        return

    def selected(self):
        self.parent.newradio(self.radio)
        return
    pass

class MyTop(Tix.Tk):
    """We have our own top-level widget so we can catch destroy calls
    and do a dialog if the data has changed"""
    def destroy(self):
        self.destroyhandler()
        return

    def realDestroy(self):
        Tix.Tk.destroy(self)
        return

    pass

class GUI(Tix.Frame):
    def __init__(self, filename, master):
        master.destroyhandler = self.quitcmd
        
        Tix.Frame.__init__(self, master)
        self.top = master
        self.pack(fill=Tix.BOTH, expand=1);
        master.geometry('800x400')
        self.createWidgets();
        self.filedialog = Tix.FileSelectDialog(master,
                                               command=self.open_select)
        self.saveasdialog = Tix.FileSelectDialog(master,
                                                 command=self.saveas_select)
        if (filename):
            self.openfile(filename)
            pass
        else:
            master.wm_title("yaesu edit")
            self.fd = None
        pass

    def openfile(self, filename):
        try:
            self.fd = RadioFileData(filename)
        except IOError, e:
            d = Dialog.Dialog(self, title="Open File",
                              text=str(e),
                              bitmap="error",
                              default = 0,
                              strings=("Ok",))
            self.fd = None
            pass

        if (not self.fd):
            return
        
        try:
            self.radioname = find_radio(self.fd.data)
            if (not self.radioname):
                d = Dialog.Dialog(self, title="Error Finding Radio",
                                  text=("Unable to find a radio that matches"
                                        + " the file %s, it is likely not a"
                                        + " radio save file.") % filename,
                                  bitmap="error",
                                  default = 0,
                                  strings=("Ok",))
                return
            self.radio = RadioConfig(radiodir + "/" + self.radioname + ".rad",
                                     self.fd)
        except Exception, e:
            exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
            traceback.print_exception(exceptionType, exceptionValue,
                                      exceptionTraceback,
                                      file=sys.stdout)
            print str(e)
            return
        self.master.wm_title(filename + " (" + self.radioname + ")")
        self.radio.setup(self)
        pass
    
    def quitcmd(self, event=None):
        if (not self.fd or not self.fd.changed):
            self.top.realDestroy()
            return
        d = Dialog.Dialog(self, title="Ok to quit?",
                          text=("Unchanged data has not been written, do you"
                                + " really want to quit?"),
                          bitmap="error",
                          default = 1,
                          strings=("Yes","No"))
        if (d.num == 0):
            self.top.realDestroy()
            pass
        pass

    def opencmd(self, event=None):
        self.filedialog.popup()
        pass

    def open_select(self, filename):
        if (not filename):
            return None
        if (not self.fd):
            g = self
            self.openfile(filename)
        else:
            g = GUI(filename, MyTop())
            pass
        return g
    
    def saveascmd(self, event=None):
        if (not self.fd):
            return
        self.saveasdialog.popup()
        pass

    def saveas_select(self, filename=None):
        if (not filename):
            return
        self.fd.write(filename)
        return
    
    def savecmd(self, event=None):
        if (self.fd.filename is None):
            return self.saveascmd()
        self.fd.write()
        return

    def newradio(self, r):
        filename = radiodir + "/" + r.name + ".empty"
        g = self.open_select(filename)
        if g:
            # Make sure to not save the file back to the empty file.
            g.fd.filename = None
            pass
        pass

    def createWidgets(self):
        self.buttons = Tix.Frame(self)
        self.buttons.pack(side=Tix.TOP, fill=Tix.X)
        
        self.filebutton = Tix.Menubutton(self.buttons, text="File",
                                         underline=0, takefocus=0)
        self.filemenu = Tix.Menu(self.filebutton, tearoff=0)
        self.filebutton["menu"] = self.filemenu
        m = Tix.Menu(self.filemenu)
        for r in radios:
            ns = RadioSel(self, r)
            m.add_command(label=r.name,
                          command = lambda ns=ns: ns.selected())
            pass
        self.filemenu.add_cascade(label="New", underline=1, menu=m)
        self.filemenu.add_command(label="Open", underline=1,
                                  accelerator="Ctrl+O",
                                  command = lambda self=self: self.opencmd() )
        self.filemenu.add_command(label="Save", underline=1,
                                  accelerator="Ctrl+S",
                                  command = lambda self=self: self.savecmd() )
        self.filemenu.add_command(label="Save As", underline=1,
                                  command = lambda self=self: self.saveascmd())
        self.filemenu.add_command(label="Exit", underline=1,
                                  accelerator="Ctrl+Q",
                                  command = lambda self=self: self.quitcmd() )
        self.top.bind_all("<Control-O>", self.opencmd)
        self.top.bind_all("<Control-o>", self.opencmd)
        self.top.bind_all("<Control-Q>", self.quitcmd)
        self.top.bind_all("<Control-q>", self.quitcmd)
        self.top.bind_all("<Control-S>", self.savecmd)
        self.top.bind_all("<Control-s>", self.savecmd)
        self.filebutton.pack(side=Tix.LEFT)
        return
    
    pass

progname = sys.argv[0]

while len(sys.argv) > 1:
    if (sys.argv[1][0] != '-'):
        break
    if (sys.argv[1] == '--'):
        del sys.argv[0]
        break
    if (sys.argv[1] == '--configdir' or sys.argv[1] == '-f'):
        if (len(sys.argv[1]) < 2):
            print "No configuration directory given with " + sys.argv[1]
            sys.exit(1)
            pass
        del sys.argv[1]
        radiodir = sys.argv[1]
        del sys.argv[1]
    else:
        print "Unknown option: " + sys.argv[1]
        sys.exit(1)
        pass
    pass

read_radios()

if (len(sys.argv) > 1):
    for filename in sys.argv[1:]:
        gui = GUI(filename, MyTop());
        pass
    pass
else:
    gui = GUI(None, MyTop());
    pass

gui.mainloop();
sys.exit(0)
